#!/bin/bash
# SPDX-License-Identifier: GPL-2.0-or-later
# Copyright (C) 2026-present Joel WirƒÅmu Pauling <aenertia@aenertia.net>

# -----------------------------------------------------------------------------
# FILE: rocknix-network-manager
# PURPOSE: Central Command Dispatcher (CLI Entry Point)
# ARCHITECTURE: Core / Dispatcher
#
# This script serves as the primary entry point for the RXNM system. It:
# 1. Bootstraps the environment (paths, library sourcing).
# 2. Normalizes user input (aliases, global flags, JSON stdin).
# 3. Dispatches commands to specific logic modules or external plugins.
#
# DESIGN NOTE: To minimize startup latency on low-power devices (RK3326),
# this script employs "Lazy Loading". It only sources the heavy logic libraries
# (wifi, bluetooth, virt) required for the specific command being executed.
# -----------------------------------------------------------------------------

# CRITICAL: Verify we are running under Bash, not BusyBox Ash
# Many string manipulation features used (arrays, regex) are Bash-specific.
if [ -z "$BASH_VERSION" ]; then
    echo "Error: This script requires bash (busybox ash not supported)" >&2
    exit 1
fi

# Debug trigger: Allows tracing execution via environment variable
if [ -n "${RXNM_DEBUG:-}" ]; then
    set -x
fi

# Ensure no ANSI color codes in output from tools like iwctl
# We parse these outputs, so escape codes break the regex.
export TERM=dumb

# Safety options:
# -u: Error on unset variables
# -o pipefail: Pipeline fails if any command fails
# nullglob: Arrays don't contain literal string if glob fails
set -euo pipefail
IFS=$'\n\t'
shopt -s nullglob

# --- BOOTSTRAP ---
# Logic: Resolve the physical location of the script to find libraries relative to it.
# This allows running from a git checkout or a system install transparently.
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do
  DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
LIB_DIR="${SCRIPT_DIR}/../lib"

# Export LIB_DIR so sourced scripts can access it
export LIB_DIR
export RXNM_LIB_DIR="${LIB_DIR}"

# Fallback: If running from /usr/bin without relative libs, check system path
if [ ! -f "${LIB_DIR}/rxnm-constants.sh" ]; then
    LIB_DIR="/usr/lib/rocknix-network-manager/lib"
    export LIB_DIR
    export RXNM_LIB_DIR="${LIB_DIR}"
fi

# Sanity Check: Cannot proceed without constants
if [ ! -f "${LIB_DIR}/rxnm-constants.sh" ]; then
    echo "ERROR: Could not locate library directory." >&2
    exit 1
fi

# Source Core: Only the absolute minimum required to parse args and find plugins
source "${LIB_DIR}/rxnm-constants.sh"
source "${LIB_DIR}/rxnm-utils.sh"
source "${LIB_DIR}/rxnm-system.sh"
source "${LIB_DIR}/rxnm-help.sh"  # Sourced early for help support
# Plugins needed for discovery
source "${LIB_DIR}/rxnm-plugins.sh"
# Schema needed for validation
source "${LIB_DIR}/rxnm-config-schema.sh"

# Lazy Load Note: config-builder.sh and templates.sh are now sourced only on demand

# --- GLOBAL VARIABLES & DEFAULTS ---
export RXNM_FORMAT="human"
export FORCE_ACTION="false"
export RXNM_GET_KEY=""
CATEGORY=""
ACTION=""

# --- ARGUMENT PARSING HELPER ---

# Function: expand_alias
# Description: Matches a partial string input against a list of valid options.
#              Used to support shortened commands (e.g., 'stat' -> 'status').
# Arguments:
#   $1 - The input string to match.
#   $2... - A list of valid options to match against.
# Globals: None.
# Returns:
#   Strings: The full option name if a unique match is found, otherwise the original input.
expand_alias() {
    local input="$1"
    local options=("${@:2}")
    local match=""
    
    if [ -z "$input" ]; then return 0; fi

    for opt in "${options[@]}"; do
        if [[ "$opt" == "$input" ]]; then
            echo "$opt"
            return 0
        fi
        if [[ "$input" != "" ]] && [[ "$opt" == "$input"* ]]; then
            if [ -n "$match" ]; then 
                # Ambiguous match found
                echo "ambiguous" 
                return 1 
            fi
            match="$opt"
        fi
    done
    
    [ -n "$match" ] && echo "$match" || echo "$input"
}

# --- GLOBAL OPTIONS PARSING ---
# Parse flags that appear before subcommands or anywhere in the chain.
ARGS=()
SHOW_HELP="false"
USE_STDIN="false"

while [[ $# -gt 0 ]]; do
    case "$1" in
        --json) RXNM_FORMAT="json"; shift ;;
        --format) RXNM_FORMAT="$2"; shift 2 ;;
        --simple) RXNM_FORMAT="simple"; shift ;;
        --get) RXNM_FORMAT="simple"; RXNM_GET_KEY="$2"; shift 2 ;;
        --yes|-y|--force) FORCE_ACTION="true"; shift ;;
        --debug) export RXNM_DEBUG=1; set -x; shift ;;
        --help|-h) SHOW_HELP="true"; shift ;;
        --stdin) USE_STDIN="true"; shift ;;
        --version) echo "RXNM ${RXNM_VERSION:-1.0.0} (API ${RXNM_API_VERSION:-1.0})"; exit 0 ;;
        *) ARGS+=("$1"); shift ;;
    esac
done

# --- JSON STDIN EXPANSION (REST LITE MODE) ---
if [ "$USE_STDIN" == "true" ]; then
    if [ -p /dev/stdin ] || [ -f /dev/stdin ]; then
        # Read the raw JSON from stdin
        INPUT_JSON=$(cat)
        
        # 0. Schema Validation (Input)
        if ! validate_json_input "$INPUT_JSON"; then
             exit 1
        fi
        
        # 1. API Version Compatibility Check
        REQ_VER=$("$JQ_BIN" -r '.api_version // empty' <<< "$INPUT_JSON")
        if [ -n "$REQ_VER" ] && [ -n "${RXNM_API_VERSION:-}" ] && [ "$REQ_VER" != "$RXNM_API_VERSION" ]; then
             # Compare major version (strict)
             if [[ "${REQ_VER%%.*}" != "${RXNM_API_VERSION%%.*}" ]]; then
                 if [ "${RXNM_FORMAT}" == "json" ] || [ "$("$JQ_BIN" -r '.format' <<< "$INPUT_JSON")" == "json" ]; then
                     echo "{\"success\": false, \"error\": \"API Version Mismatch\", \"supported\": \"$RXNM_API_VERSION\", \"requested\": \"$REQ_VER\"}"
                     exit 1
                 else
                     echo "Error: API Version Mismatch (Server: $RXNM_API_VERSION, Client: $REQ_VER)" >&2
                     exit 1
                 fi
             fi
        fi

        # 2. Extract Core Commands
        JSON_CAT=$("$JQ_BIN" -r '.category // empty' <<< "$INPUT_JSON")
        JSON_ACT=$("$JQ_BIN" -r '.action // empty' <<< "$INPUT_JSON")
        
        # 3. Extract Globals (Overrides)
        J_FMT=$("$JQ_BIN" -r '.format // empty' <<< "$INPUT_JSON")
        J_JSON=$("$JQ_BIN" -r '.json // false' <<< "$INPUT_JSON")
        J_FORCE=$("$JQ_BIN" -r '.force // .yes // false' <<< "$INPUT_JSON")
        
        if [ "$J_FMT" == "json" ] || [ "$J_JSON" == "true" ]; then RXNM_FORMAT="json"; fi
        if [ "$J_FORCE" == "true" ]; then FORCE_ACTION="true"; fi
        
        if [ -n "$JSON_CAT" ]; then
            # Rebuild ARGS array from JSON structure
            ARGS=("$JSON_CAT")
            [ -n "$JSON_ACT" ] && ARGS+=("$JSON_ACT")
            
            # Map JSON keys to CLI flags
            # Normalizes snake_case keys (api_version) to kebab-case flags (--api-version)
            while IFS= read -r line; do
                ARGS+=("$line")
            done < <("$JQ_BIN" -r '
                del(.category, .action, .json, .format, .yes, .force, .api_version) | 
                to_entries[] | 
                select(.value != null and .value != false) | 
                if (.value | type) == "boolean" and .value == true then 
                    "--" + (.key | gsub("_";"-")) 
                elif (.value | type) == "array" then
                    "--" + (.key | gsub("_";"-")) + "\n" + (.value | join(","))
                else 
                    "--" + (.key | gsub("_";"-")) + "\n" + (.value | tostring) 
                end
            ' <<< "$INPUT_JSON")
        else
             # Error out if no category provided in JSON
             if [ "${RXNM_FORMAT}" == "json" ]; then
                 echo '{"success": false, "error": "Invalid JSON input: category required"}'
                 exit 1
             else
                 echo "Error: Invalid JSON input (category required)" >&2
                 exit 1
             fi
        fi
    fi
fi

# Reset positional arguments to the expanded/normalized ARGS array
set -- "${ARGS[@]}"

# If help requested at root (or explicit global help)
if [ "$SHOW_HELP" == "true" ] && [ $# -eq 0 ]; then
    rxnm_help_show_main
    exit 0
fi

# --- HIERARCHY DISPATCHER ---

# List of Built-in Categories
# Added SOA categories: service, route, tunnel, mpls, pppoe, ha
CATS=("wifi" "interface" "bluetooth" "bridge" "bond" "vrf" "vlan" "macvlan" "ipvlan" "veth" "vpn" "tun" "tap" "profile" "system" "config" "api" "service" "route" "tunnel" "mpls" "pppoe" "ha")

# Determine Category from first argument
RAW_CMD="${1:-}"
CATEGORY=""

if [ -n "$RAW_CMD" ]; then
    CATEGORY=$(expand_alias "$RAW_CMD" "${CATS[@]}")
    # Handle ambiguous expansion
    if [ "$CATEGORY" == "ambiguous" ]; then
        json_error "Ambiguous command: '$RAW_CMD'. Please be more specific." "1"
        exit 1
    fi
else
    # No category provided
    if [ "$SHOW_HELP" == "true" ]; then
        rxnm_help_show_main
        exit 0
    fi
    # Default behavior: system status
    CATEGORY="system"
    # IMPORTANT: Inject 'system status' arguments so the shift logic works downstream
    set -- "system" "status"
fi

# Category Aliases (Mapping)
case "$CATEGORY" in
    if|iface) CATEGORY="interface" ;;
    bt) CATEGORY="bluetooth" ;;
    sys) CATEGORY="system" ;;
    virt) CATEGORY="bridge" ;; # Or generic virt handling
    svc) CATEGORY="service" ;;
esac

# 1. Plugin Dispatch (Highest Priority)
# Check if a plugin exists for this category (Extension or Override)
PLUGIN_EXEC=$(find_plugin "$CATEGORY" || true)

if [ -n "$PLUGIN_EXEC" ]; then
    # If a plugin is found, we hand over control immediately.
    shift
    
    # Check for help on the plugin itself if requested
    if [ "$SHOW_HELP" == "true" ]; then
        exec_plugin "$PLUGIN_EXEC" "--help"
        exit 0
    fi
    
    exec_plugin "$PLUGIN_EXEC" "$@"
fi

# 2. Built-in Dispatch
IS_VALID_CAT=false
for valid_cat in "${CATS[@]}"; do
    if [[ "$valid_cat" == "$CATEGORY" ]]; then
        IS_VALID_CAT=true
        break
    fi
done

if [ "$IS_VALID_CAT" = false ]; then
    if [ "$SHOW_HELP" == "true" ]; then
        # If user asked for help on an invalid category, show main help
        rxnm_help_show_main
        exit 0
    fi
    
    json_error "Unknown command or category: $RAW_CMD" "1" "Try 'rxnm --help'"
    exit 1
else
    shift
fi

# CRITICAL FIX: Handle help request before dispatching action
# This prevents "rxnm interface --help" from trying to execute an action named "--help"
if [ "$SHOW_HELP" == "true" ]; then
    rxnm_help_show_category "$CATEGORY"
    exit 0
fi

# Load Dependencies (Lazy Loading)
# Logic: We only source the bash libraries required for the requested category
# to reduce startup time.
case "$CATEGORY" in
    wifi) 
        source "${LIB_DIR}/rxnm-wifi.sh" 
        source "${LIB_DIR}/rxnm-interfaces.sh" 
        source "${LIB_DIR}/rxnm-roaming.sh"
        ;;
    interface|bridge) 
        source "${LIB_DIR}/rxnm-interfaces.sh" 
        source "${LIB_DIR}/rxnm-diagnostics.sh"
        ;;
    vpn|tun|tap) 
        source "${LIB_DIR}/rxnm-interfaces.sh" 
        source "${LIB_DIR}/rxnm-vpn.sh" 
        ;;
    bond|vlan|vrf|macvlan|ipvlan|veth) 
        source "${LIB_DIR}/rxnm-interfaces.sh" 
        source "${LIB_DIR}/rxnm-virt.sh" 
        source "${LIB_DIR}/rxnm-diagnostics.sh"
        ;;
    bluetooth) source "${LIB_DIR}/rxnm-bluetooth.sh" ;;
    profile) source "${LIB_DIR}/rxnm-profiles.sh" ;;
    system|config) 
        source "${LIB_DIR}/rxnm-diagnostics.sh" 
        source "${LIB_DIR}/rxnm-wifi.sh" 
        source "${LIB_DIR}/rxnm-nullify.sh"
        source "${LIB_DIR}/rxnm-interfaces.sh"
        # Templates needed for 'setup'
        source "${LIB_DIR}/rxnm-templates.sh"
        ;;
    service) source "${LIB_DIR}/rxnm-service.sh" ;;
    route) source "${LIB_DIR}/rxnm-routes.sh" ;;
    tunnel) source "${LIB_DIR}/rxnm-tunnel.sh" ;;
    mpls) source "${LIB_DIR}/rxnm-mpls.sh" ;;
    pppoe) source "${LIB_DIR}/rxnm-pppoe.sh" ;;
    ha) source "${LIB_DIR}/rxnm-ha.sh" ;;
    api) ;;
esac

# Batch 2: Configuration State Validation & Deferred Loading
# Check intent against schema before execution
if [[ "$CATEGORY" == "wifi" ]] || [[ "$CATEGORY" == "interface" ]] || \
   [[ "$CATEGORY" == "bridge" ]] || [[ "$CATEGORY" == "bond" ]] || \
   [[ "$CATEGORY" == "vlan" ]] || [[ "$CATEGORY" == "vrf" ]]; then
    
    # We grab the first argument as potential action for descriptor building
    VAL_ACTION="${1:-}"
    
    # Special handling for interface dispatch where arg 1 might be interface name
    if [[ "$CATEGORY" == "interface" ]]; then
        # If arg 1 is not a command, it's a target, so action is arg 2
        # Simple heuristic: Is arg1 an action keyword?
        if ! [[ "$VAL_ACTION" =~ ^(show|set|enable|disable|list|hotplug)$ ]]; then
             VAL_ACTION="${2:-}"
        fi
    fi

    # Optimization: Only load builders/templates if we are likely modifying configuration
    if [[ "$VAL_ACTION" =~ ^(set|create|delete|add.*|connect|disconnect|ap)$ ]]; then
        source "${LIB_DIR}/rxnm-config-builder.sh"
        source "${LIB_DIR}/rxnm-templates.sh"
        
        descriptor=$(build_config_descriptor "$CATEGORY" "$VAL_ACTION" "$@")
        if ! validate_config_state "$descriptor"; then
            # Error is handled inside validation function (json_error)
            exit 1
        fi
    fi
fi

# Dispatch to Category Handlers
case "$CATEGORY" in
    api)
        ACTION="${1:-schema}"
        case "$ACTION" in
            schema)
                SCHEMA_FILE="${LIB_DIR}/../api-schema.json"
                if [ -f "$SCHEMA_FILE" ]; then
                    cat "$SCHEMA_FILE"
                else
                    echo '{"error": "Schema file not found"}'
                fi
                ;;
            version)
                json_success "{\"version\": \"${RXNM_VERSION}\", \"api\": \"${RXNM_API_VERSION:-1.0}\"}"
                ;;
            capabilities)
                # Introspection of available features/stubs
                netd_ver=$(networkctl --version 2>/dev/null | grep -oP 'systemd \K\d+' || echo 0)
                agent_active="false"
                if [ -x "${RXNM_AGENT_BIN}" ]; then agent_active="true"; fi
                
                "$JQ_BIN" -n \
                    --arg netd "$netd_ver" \
                    --argjson agent "$agent_active" \
                    '{
                        success: true,
                        systemd_networkd_version: ($netd | tonumber),
                        agent_available: $agent,
                        features: {
                            wifi: {status: "stable", since_version: "1.0"},
                            interface: {status: "stable", since_version: "1.0"},
                            nullify: {status: "beta", since_version: "1.1"},
                            service: {status: "experimental", since_version: "1.0"},
                            route: {status: "experimental", since_version: "1.0"},
                            tunnel: {status: "experimental", since_version: "1.0"},
                            mpls: {status: "deferred", since_version: "1.1"},
                            pppoe: {status: "deferred", since_version: "1.1"},
                            ha: {status: "deferred", since_version: "1.1"}
                        }
                    }'
                ;;
        esac
        ;;

    wifi)
        ACTION=$(expand_alias "${1:-status}" "scan" "connect" "disconnect" "ap" "wps" "networks" "country" "list" "forget" "p2p" "dpp" "roaming")
        if [ $# -gt 0 ]; then shift; fi
        
        ARG_IFACE=""
        ARGS=("$@")
        # Extract --interface if provided
        for ((i=0; i<${#ARGS[@]}; i++)); do
            if [[ "${ARGS[$i]}" == "--interface" ]]; then
                ARG_IFACE="${ARGS[$((i+1))]}"
            fi
        done
        # Roaming monitor might run without a specific iface initially, but we auto-detect
        if [ -z "$ARG_IFACE" ] && [ "$ACTION" != "roaming" ]; then
             ARG_IFACE=$(get_wifi_iface || echo "")
        fi

        case "$ACTION" in
            scan)
                action_scan "$ARG_IFACE"
                ;;
            connect)
                SSID="${1:-}"; [ -n "$SSID" ] && shift
                PASS="${1:-}"; [ -n "$PASS" ] && [[ "$PASS" != --* ]] && shift
                HIDDEN="false"
                while [[ $# -gt 0 ]]; do
                    case "$1" in
                        --ssid) SSID="$2"; shift 2 ;;
                        --password) PASS="$2"; shift 2 ;;
                        --password-stdin) PASS=$(cat); shift ;;
                        --hidden) HIDDEN="true"; shift ;;
                        --interface) ARG_IFACE="$2"; shift 2 ;;
                        *) shift ;;
                    esac
                done
                action_connect "$SSID" "$PASS" "$ARG_IFACE" "$HIDDEN"
                ;;
            disconnect)
                 while [[ $# -gt 0 ]]; do
                    case "$1" in --interface) ARG_IFACE="$2"; shift 2 ;; *) shift ;; esac
                done
                action_disconnect "$ARG_IFACE"
                ;;
            ap)
                SUBCMD="${1:-}"; shift
                if [ "$SUBCMD" == "start" ]; then
                    SSID="${1:-}"; [ -n "$SSID" ] && shift
                    PASS="${1:-}"; [ -n "$PASS" ] && [[ "$PASS" != --* ]] && shift
                    MODE="ap"; SHARE="false"; IP=""; IPV6_PD="yes"
                     while [[ $# -gt 0 ]]; do
                        case "$1" in
                            --ssid) SSID="$2"; shift 2 ;;
                            --password) PASS="$2"; shift 2 ;;
                            --mode) MODE="$2"; shift 2 ;;
                            --share) SHARE="true"; shift ;;
                            --ip) IP="$2"; shift 2 ;;
                            --interface) ARG_IFACE="$2"; shift 2 ;;
                            --ipv6-pd) IPV6_PD="$2"; shift 2 ;;
                            *) shift ;;
                        esac
                    done
                    action_host "$SSID" "$PASS" "$MODE" "$SHARE" "$IP" "$ARG_IFACE" "" "$IPV6_PD"
                elif [ "$SUBCMD" == "stop" ]; then
                    while [[ $# -gt 0 ]]; do
                        case "$1" in --interface) ARG_IFACE="$2"; shift 2 ;; *) shift ;; esac
                    done
                    action_client "$ARG_IFACE"
                fi
                ;;
            wps)
                action_wps "$ARG_IFACE"
                ;;
            networks|list)
                action_list_known_networks
                ;;
            forget)
                 SSID="${1:-}"; [ -n "$SSID" ] && shift
                 confirm_action "Forget network '$SSID'?" "$FORCE_ACTION"
                 action_forget "$SSID"
                 ;;
            country)
                action_set_country "${1:-}"
                ;;
            p2p)
                SUBCMD="${1:-}"; shift
                case "$SUBCMD" in
                    scan) action_p2p_scan ;;
                    connect) action_p2p_connect "${1:-}" ;;
                    disconnect) action_p2p_disconnect ;;
                    status) action_p2p_status ;;
                esac
                ;;
            dpp)
                SUBCMD="${1:-}"; shift
                if [ "$SUBCMD" == "enroll" ]; then action_dpp_enroll "$ARG_IFACE" "${1:-}"; fi
                if [ "$SUBCMD" == "stop" ]; then action_dpp_stop "$ARG_IFACE"; fi
                ;;
            roaming)
                SUBCMD="${1:-}"; shift
                case "$SUBCMD" in
                    monitor)
                        action_wifi_roaming_monitor "$@"
                        ;;
                    enable)
                        systemctl enable --now rxnm-roaming
                        json_success '{"action": "roaming_enable", "status": "active"}'
                        ;;
                    disable)
                        systemctl disable --now rxnm-roaming
                        json_success '{"action": "roaming_disable", "status": "inactive"}'
                        ;;
                    *)
                        echo "Usage: rxnm wifi roaming {monitor|enable|disable}"
                        ;;
                esac
                ;;
        esac
        ;;

    interface)
        ARG_1="${1:-}"
        TARGET=""
        ACTION=""
        
        # Valid actions for this category
        VALID_ACTS=("show" "set" "enable" "disable" "list" "hotplug")
        
        # Attempt expansion of first arg as a keyword
        EXPANDED=$(expand_alias "$ARG_1" "${VALID_ACTS[@]}")
        
        # Validate if the expanded result is actually one of our keywords
        IS_KEYWORD=false
        for v in "${VALID_ACTS[@]}"; do
            if [[ "$v" == "$EXPANDED" ]]; then IS_KEYWORD=true; break; fi
        done
        
        if [ "$IS_KEYWORD" == "true" ]; then
            # Command-first syntax: rxnm interface set eth0 ...
            ACTION="$EXPANDED"
            if [ $# -gt 0 ]; then shift; fi
            # If next arg is not a flag, it's the target
            if [[ "${1:-}" != --* ]] && [ -n "${1:-}" ]; then
                TARGET="$1"
                shift
            fi
        else
            # Object-first syntax: rxnm interface eth0 set ...
            TARGET="$ARG_1"
            if [ $# -gt 0 ]; then shift; fi
            ACTION=$(expand_alias "${1:-show}" "${VALID_ACTS[@]}")
            if [ $# -gt 0 ]; then shift; fi
        fi
        
        # Flag args override
        ARGS=("$@")
        while [[ $# -gt 0 ]]; do
             case "$1" in 
                --interface) TARGET="$2"; shift 2 ;; 
                *) shift ;; 
             esac
        done
        # Reset args for subcommand parsing
        set -- "${ARGS[@]}"

        case "$ACTION" in
            show) action_status "$TARGET" ;;
            enable)
                [ -z "$TARGET" ] && { json_error "Interface name required"; exit 1; }
                action_set_link "$TARGET" "on" "on"
                ;;
            disable)
                [ -z "$TARGET" ] && { json_error "Interface name required"; exit 1; }
                action_set_link "$TARGET" "off" "off"
                ;;
            hotplug)
                [ -z "$TARGET" ] && { json_error "Interface name required"; exit 1; }
                action_hotplug "$TARGET"
                ;;
            set)
                SUBCMD="${1:-}"; shift
                
                # Check for hardware override
                if [ "$SUBCMD" == "hardware" ]; then
                     SPEED=""; DUPLEX=""; AUTONEG=""; WOL=""; MACPOL=""; NAMEPOL=""; MAC=""
                     while [[ $# -gt 0 ]]; do
                        case "$1" in
                            --speed) SPEED="$2"; shift 2 ;;
                            --duplex) DUPLEX="$2"; shift 2 ;;
                            --autoneg) AUTONEG="$2"; shift 2 ;;
                            --wol) WOL="$2"; shift 2 ;;
                            --mac-policy) MACPOL="$2"; shift 2 ;;
                            --name-policy) NAMEPOL="$2"; shift 2 ;;
                            --mac) MAC="$2"; shift 2 ;;
                            *) shift ;;
                        esac
                     done
                     action_set_hardware "$TARGET" "$SPEED" "$DUPLEX" "$AUTONEG" "$WOL" "$MACPOL" "$NAMEPOL" "$MAC"
                     exit 0
                fi

                # Standard Configuration
                METRIC=""
                MTU=""
                MAC=""
                IPV6_PRIV=""
                DHCP_ID=""
                IPV6_PD=""
                case "$SUBCMD" in
                    dhcp)
                         ROUTES=""
                         DNS=""
                         DOMAINS=""
                         while [[ $# -gt 0 ]]; do
                            case "$1" in 
                                --metric) METRIC="$2"; shift 2 ;; 
                                --mtu) MTU="$2"; shift 2 ;;
                                --mac) MAC="$2"; shift 2 ;;
                                --ipv6-privacy) IPV6_PRIV="$2"; shift 2 ;;
                                --dhcp-id) DHCP_ID="$2"; shift 2 ;;
                                --ipv6-pd) IPV6_PD="$2"; shift 2 ;;
                                --routes) ROUTES="$2"; shift 2 ;;
                                --dns) DNS="$2"; shift 2 ;;
                                --domains) DOMAINS="$2"; shift 2 ;;
                                *) shift ;; 
                            esac
                        done
                         action_set_dhcp "$TARGET" "" "$DNS" "$DOMAINS" "$ROUTES" "yes" "yes" "$METRIC" "$MTU" "$MAC" "$IPV6_PRIV" "$DHCP_ID" "$IPV6_PD"
                         ;;
                    static)
                         IP="${1:-}"; [ -n "$IP" ] && [[ "$IP" != --* ]] && shift
                         GW=""; DNS=""; ROUTES=""; DOMAINS=""
                         while [[ $# -gt 0 ]]; do
                            case "$1" in
                                --ip) IP="$2"; shift 2 ;;
                                --gateway) GW="$2"; shift 2 ;;
                                --dns) DNS="$2"; shift 2 ;;
                                --domains) DOMAINS="$2"; shift 2 ;;
                                --metric) METRIC="$2"; shift 2 ;;
                                --mtu) MTU="$2"; shift 2 ;;
                                --mac) MAC="$2"; shift 2 ;;
                                --ipv6-privacy) IPV6_PRIV="$2"; shift 2 ;;
                                --dhcp-id) DHCP_ID="$2"; shift 2 ;;
                                --routes) ROUTES="$2"; shift 2 ;;
                                *) shift ;;
                            esac
                        done
                         action_set_static "$TARGET" "$IP" "$GW" "$DNS" "" "$DOMAINS" "$ROUTES" "yes" "yes" "$METRIC" "$MTU" "$MAC" "$IPV6_PRIV" "$DHCP_ID"
                         ;;
                esac
                ;;
            list) action_status "" ;;
        esac
        ;;
        
    system)
        ACTION=$(expand_alias "${1:-status}" "status" "check" "proxy" "reload" "setup" "start" "stop" "nullify")
        if [ $# -gt 0 ]; then shift; fi
        
        case "$ACTION" in
            status) action_status "${1:-}" ;;
            check)
                SUBCMD="${1:-}"; shift
                if [ "$SUBCMD" == "internet" ]; then action_check_internet; fi
                if [ "$SUBCMD" == "portal" ]; then action_check_portal "${1:-}"; fi
                ;;
            proxy)
                 SUBCMD="${1:-}"; shift
                 if [ "$SUBCMD" == "set" ]; then
                    HTTP=""; HTTPS=""; NO=""; IFACE=""
                    while [[ $# -gt 0 ]]; do
                        case "$1" in
                            --http) HTTP="$2"; shift 2 ;;
                            --https) HTTPS="$2"; shift 2 ;;
                            --noproxy) NO="$2"; shift 2 ;;
                            --interface) IFACE="$2"; shift 2 ;;
                            *) shift ;;
                        esac
                    done
                    action_set_proxy "$IFACE" "$HTTP" "$HTTPS" "$NO"
                 fi
                 ;;
            reload) action_reload ;;
            setup|start) 
                init_template_cache
                action_setup 
                ;;
            stop) action_stop ;;
            nullify) 
                # 1.1.0 Fix: Pass ALL arguments to handle flags like --interface
                action_system_nullify "$@" 
                ;;
        esac
        ;;
        
    bluetooth)
        ACTION="${1:-}"; 
        if [ $# -gt 0 ]; then shift; fi
        
        case "$ACTION" in
            pan)
                SUBCMD="${1:-}"; shift
                MODE="client"; SHARE="false"; IP=""
                case "$SUBCMD" in
                    enable)
                        while [[ $# -gt 0 ]]; do
                            case "$1" in
                                --mode) MODE="$2"; shift 2 ;;
                                --share) SHARE="true"; shift ;;
                                --ip) IP="$2"; shift 2 ;;
                                *) shift ;;
                            esac
                        done
                        action_pan_net "enable" "" "" "$IP" "$MODE" "$SHARE"
                        ;;
                    disable) action_pan_net "disable" "" "" "" "" "" ;;
                esac
                ;;
            scan) action_bt_scan ;;
            pair)
                MAC="${1:-}"; shift
                [ -z "$MAC" ] && { json_error "MAC address required"; exit 1; }
                action_bt_pair "$MAC"
                ;;
            unpair)
                MAC="${1:-}"; shift
                [ -z "$MAC" ] && { json_error "MAC address required"; exit 1; }
                action_bt_unpair "$MAC"
                ;;
        esac
        ;;

    bridge|bond|vrf|vlan|macvlan|ipvlan|veth)
         ACTION="${1:-}"; 
         if [ $# -gt 0 ]; then shift; fi
         
         NAME="${1:-}"; [ -n "$NAME" ] && [[ "$NAME" != --* ]] && shift
         
         if [ "$ACTION" == "delete" ]; then
             [ -z "$NAME" ] && { json_error "Name required"; exit 1; }
             action_delete_netdev "$NAME"
             exit 0
         fi
         
         # Enable generic listing for these categories
         if [ "$ACTION" == "list" ]; then
             action_status ""
             exit 0
         fi
         
         case "$CATEGORY" in
            bridge)
                if [ "$ACTION" == "create" ]; then action_create_bridge "$NAME"; fi
                if [ "$ACTION" == "add-member" ]; then
                     IFACE="${1:-}"; 
                     if [ -z "$IFACE" ] || [[ "$IFACE" == --* ]]; then IFACE="$NAME"; fi
                     BRIDGE=""
                     while [[ $# -gt 0 ]]; do case "$1" in --bridge) BRIDGE="$2"; shift 2;; *) shift ;; esac; done
                     action_set_member "$IFACE" "$BRIDGE"
                fi
                ;;
            bond)
                if [ "$ACTION" == "create" ]; then action_create_bond "$NAME" "active-backup"; fi
                if [ "$ACTION" == "add-slave" ]; then
                     IFACE="${1:-}";
                     if [ -z "$IFACE" ] || [[ "$IFACE" == --* ]]; then IFACE="$NAME"; fi
                     BOND=""
                     while [[ $# -gt 0 ]]; do case "$1" in --bond) BOND="$2"; shift 2;; *) shift ;; esac; done
                     action_set_bond_slave "$IFACE" "$BOND"
                fi
                ;;
            vrf)
                if [ "$ACTION" == "create" ]; then
                     TABLE=""
                     while [[ $# -gt 0 ]]; do case "$1" in --table) TABLE="$2"; shift 2 ;; *) shift ;; esac; done
                     action_create_vrf "$NAME" "$TABLE"
                fi
                if [ "$ACTION" == "add-member" ]; then
                     IFACE="${1:-}";
                     if [ -z "$IFACE" ] || [[ "$IFACE" == --* ]]; then IFACE="$NAME"; fi
                     VRF=""
                     while [[ $# -gt 0 ]]; do case "$1" in --vrf) VRF="$2"; shift 2;; *) shift ;; esac; done
                     action_set_vrf_member "$IFACE" "$VRF"
                fi
                ;;
            vlan)
                if [ "$ACTION" == "create" ]; then
                     PARENT=""; ID=""
                     while [[ $# -gt 0 ]]; do
                        case "$1" in 
                            --parent) PARENT="$2"; shift 2 ;;
                            --id) ID="$2"; shift 2 ;;
                            *) shift ;;
                        esac
                     done
                     [ -z "$PARENT" ] && { json_error "Parent required (--parent)"; exit 1; }
                     [ -z "$ID" ] && { json_error "ID required (--id)"; exit 1; }
                     action_create_vlan "$PARENT" "$NAME" "$ID"
                fi
                ;;
            macvlan)
                if [ "$ACTION" == "create" ]; then
                     PARENT=""; MODE="bridge"
                     while [[ $# -gt 0 ]]; do
                        case "$1" in
                            --parent) PARENT="$2"; shift 2 ;;
                            --mode) MODE="$2"; shift 2 ;;
                            *) shift ;;
                        esac
                     done
                     action_create_macvlan "$NAME" "$PARENT" "$MODE"
                fi
                ;;
         esac
         ;;

    vpn|tun|tap)
        if [[ "$CATEGORY" == "tun" || "$CATEGORY" == "tap" ]] || [[ "$1" == "tun" || "$1" == "tap" ]]; then
             KIND="$CATEGORY"; [ "$KIND" == "vpn" ] && KIND="$1" && shift
             ACTION="${1:-create}"; shift; NAME="${1:-}"; shift
             USER=""; GROUP=""
             if [ "$ACTION" == "delete" ]; then action_delete_vpn "$NAME"; exit 0; fi
             while [[ $# -gt 0 ]]; do
                case "$1" in --user) USER="$2"; shift 2;; --group) GROUP="$2"; shift 2;; *) shift ;; esac
             done
             [ "$KIND" == "tun" ] && action_create_tun "$NAME" "$USER" "$GROUP"
             [ "$KIND" == "tap" ] && action_create_tap "$NAME" "$USER" "$GROUP"
             exit 0
        fi

        if [ "$1" == "wireguard" ]; then shift; fi
        ACTION="${1:-}"; shift; NAME="${1:-}"; [ -n "$NAME" ] && [[ "$NAME" != --* ]] && shift
        case "$ACTION" in
            connect)
                PRIV=""; PEER=""; ENDP=""; IPS=""; IP=""
                while [[ $# -gt 0 ]]; do
                    case "$1" in
                        --private-key) PRIV="$2"; shift 2 ;;
                        --peer-key) PEER="$2"; shift 2 ;;
                        --endpoint) ENDP="$2"; shift 2 ;;
                        --allowed-ips) IPS="$2"; shift 2 ;;
                        --address) IP="$2"; shift 2 ;;
                        *) shift ;;
                    esac
                done
                action_connect_wireguard "$NAME" "$PRIV" "$PEER" "$ENDP" "$IPS" "$IP" ""
                ;;
            disconnect|delete) action_disconnect_wireguard "$NAME" ;;
        esac
        ;;

    profile)
        ACTION="${1:-}"; shift; NAME="${1:-}"; [ -n "$NAME" ] && [[ "$NAME" != --* ]] && shift
        IFACE=""; FILE=""
        while [[ $# -gt 0 ]]; do
             case "$1" in 
                 --interface) IFACE="$2"; shift 2 ;; 
                 --file) FILE="$2"; shift 2 ;;
                 *) shift ;; 
             esac
        done
        if [ "$ACTION" == "import" ] && [ -z "$FILE" ] && [ -f "$NAME" ]; then FILE="$NAME"; fi
        action_profile "$ACTION" "$NAME" "$IFACE" "$FILE"
        ;;
    
    # --- SERVICE ORIENTED ARCHITECTURE (v1.0 Hybrid) ---
    service)
        ACTION="${1:-list}"; shift
        NAME="${1:-}"; [ -n "$NAME" ] && [[ "$NAME" != --* ]] && shift
        
        case "$ACTION" in
            create) action_service_create "$NAME" ;;
            delete) action_service_delete "$NAME" ;;
            list) action_service_list ;;
            attach)
                IFACE=""; while [[ $# -gt 0 ]]; do case "$1" in --interface) IFACE="$2"; shift 2;; *) shift ;; esac; done
                [ -z "$IFACE" ] && { IFACE="$NAME"; NAME=""; }
                action_service_attach "$NAME" "$IFACE"
                ;;
            detach)
                IFACE=""; while [[ $# -gt 0 ]]; do case "$1" in --interface) IFACE="$2"; shift 2;; *) shift ;; esac; done
                [ -z "$IFACE" ] && { IFACE="$NAME"; NAME=""; }
                action_service_detach "$NAME" "$IFACE"
                ;;
            exec)
                action_service_exec "$NAME" "$@"
                ;;
        esac
        ;;
        
    route)
        ACTION="${1:-list}"; shift
        action_route_dispatch "$ACTION" "$@"
        ;;
        
    tunnel)
        ACTION="${1:-list}"; shift
        action_tunnel_dispatch "$ACTION" "$@"
        ;;
        
    mpls)
        ACTION="${1:-list}"; shift
        action_mpls_dispatch "$ACTION" "$@"
        ;;
        
    pppoe)
        ACTION="${1:-list}"; shift
        action_pppoe_dispatch "$ACTION" "$@"
        ;;
        
    ha)
        ACTION="${1:-list}"; shift
        action_ha_dispatch "$ACTION" "$@"
        ;;
        
    *)
        json_error "Command category '$CATEGORY' not implemented yet." "1"; exit 1 ;;
esac
