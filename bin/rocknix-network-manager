#!/bin/bash
# SPDX-License-Identifier: GPL-2.0-or-later
# Copyright (C) 2026-present Joel WirƒÅmu Pauling <aenertia@aenertia.net>
#
# ROCKNIX Network Manager (Modular)
# Phase 3: UX Refactor (Target-First, Help System, Formatting)

# Debug trigger
if [ -n "${RXNM_DEBUG:-}" ]; then
    set -x
fi

# Ensure no ANSI color codes in output from tools like iwctl
export TERM=dumb

# Safety options
set -euo pipefail
IFS=$'\n\t'
shopt -s nullglob

# --- BOOTSTRAP ---
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do
  DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
LIB_DIR="${SCRIPT_DIR}/../lib"

if [ ! -f "${LIB_DIR}/rxnm-constants.sh" ]; then
    LIB_DIR="/usr/lib/rocknix-network-manager/lib"
fi

if [ ! -f "${LIB_DIR}/rxnm-constants.sh" ]; then
    echo "ERROR: Could not locate library directory." >&2
    exit 1
fi

# Source Core
source "${LIB_DIR}/rxnm-constants.sh"
source "${LIB_DIR}/rxnm-utils.sh"
source "${LIB_DIR}/rxnm-system.sh"
source "${LIB_DIR}/rxnm-config-builder.sh"

# --- GLOBAL VARIABLES & DEFAULTS ---
export RXNM_FORMAT="human"
FORCE_ACTION="false"
CATEGORY=""
ACTION=""

# --- ARGUMENT PARSING HELPER ---
# Simple prefix matcher for short aliases (e.g., 'wi' -> 'wifi')
expand_alias() {
    local input="$1"
    local options=("${@:2}")
    local match=""
    
    for opt in "${options[@]}"; do
        if [[ "$opt" == "$input" ]]; then
            echo "$opt"
            return 0
        fi
        if [[ "$opt" == "$input"* ]]; then
            if [ -n "$match" ]; then return 1; fi # Ambiguous
            match="$opt"
        fi
    done
    
    [ -n "$match" ] && echo "$match" || echo "$input"
}

print_main_help() {
    cat <<EOF
Usage: rxnm <category> [target] <action> [options]

Categories:
  wifi          Manage Wireless connections
  interface     Configure interfaces (IP, DHCP, State)
  system        Status, diagnostics, global settings
  profile       Manage configuration profiles
  bluetooth     Bluetooth Tethering (PAN/NAP)
  vpn           WireGuard and Tunnels
  bridge        Manage Network Bridges
  bond          Manage Interface Bonding
  vlan          Manage VLANs
  vrf           Manage Virtual Routing Functions

Global Options:
  --format <fmt>  Output format: human (default), json, table
  --yes, -y       Skip confirmation prompts
  --help, -h      Show help
  --version       Show version

Examples:
  rxnm wifi connect "MyNetwork"
  rxnm interface wlan0 set dhcp
  rxnm system status --format table
  rxnm bridge create br0

Use 'rxnm <category> --help' for specific commands.
EOF
}

print_category_help() {
    local cat="$1"
    case "$cat" in
        wifi)
            cat <<EOF
Usage: rxnm wifi <action> [options]

Actions:
  scan [iface]          Scan for networks
  connect <ssid>        Connect to a network
  disconnect [iface]    Disconnect from current AP
  list                  List known networks
  forget <ssid>         Forget a known network
  ap start <ssid>       Start Access Point (Hotspot)
  country <code>        Set WiFi Country Code

Options:
  --password <pass>     WiFi Password
  --password-stdin      Read password from stdin (Secure)
  --hidden              Connect to hidden SSID
  --interface <iface>   Target interface (Auto-detected if omitted)
EOF
            ;;
        interface)
            cat <<EOF
Usage: rxnm interface [name] <action> [options]

Actions:
  show                  Show interface details
  set dhcp              Enable DHCP
  set static <ip>       Set Static IP (CIDR format)
  enable / disable      Set link state

Options:
  --gateway <ip>        Set Gateway
  --dns <ip>            Set DNS servers (comma separated)
  --metric <int>        Route metric priority
EOF
            ;;
        profile)
            cat <<EOF
Usage: rxnm profile <action> [name] [options]

Actions:
  list                  List saved profiles
  save <name>           Save current state to profile
  load <name>           Load profile
  delete <name>         Delete profile
  export <name>         Export profile to file
  import <file>         Import profile from file

Options:
  --interface <iface>   Scope profile to specific interface
EOF
            ;;
        bridge|bond|vlan|vrf)
            cat <<EOF
Usage: rxnm $cat <action> <name> [options]

Actions:
  create <name>         Create new virtual device
  delete <name>         Delete device
  add-member <iface>    Add interface to $cat
  list                  List devices

Options vary by type (e.g., --id for VLAN, --mode for Bond).
EOF
            ;;
        vpn)
            cat <<EOF
Usage: rxnm vpn wireguard <action> <name> [options]

Actions:
  connect <name>        Create/Connect WireGuard interface
  disconnect <name>     Remove WireGuard interface
  delete <name>         Alias for disconnect

Options:
  --private-key, --peer-key, --endpoint, --allowed-ips, --address
EOF
            ;;
        *)
            echo "No specific help for '$cat'."
            ;;
    esac
}

# --- GLOBAL OPTIONS PARSING ---
# Parse flags that appear before subcommands or anywhere
ARGS=()
SHOW_HELP="false"

while [[ $# -gt 0 ]]; do
    case "$1" in
        --json) RXNM_FORMAT="json"; shift ;;
        --format) RXNM_FORMAT="$2"; shift 2 ;;
        --yes|-y|--force) FORCE_ACTION="true"; shift ;;
        --debug) export RXNM_DEBUG=1; set -x; shift ;;
        --help|-h) SHOW_HELP="true"; shift ;;
        *) ARGS+=("$1"); shift ;;
    esac
done
set -- "${ARGS[@]}"

# If help requested at root
if [ "$SHOW_HELP" == "true" ] && [ $# -eq 0 ]; then
    print_main_help
    exit 0
fi

# --- HIERARCHY DISPATCHER ---

# Categories
CATS=("wifi" "interface" "bluetooth" "bridge" "bond" "vrf" "vlan" "macvlan" "ipvlan" "veth" "vpn" "tun" "tap" "profile" "system" "config")

# Determine Category
RAW_CMD="${1:-status}"
CATEGORY=$(expand_alias "$RAW_CMD" "${CATS[@]}")

# Validate Category
if [[ ! " ${CATS[*]} " =~ " ${CATEGORY} " ]]; then
    if [ -z "$RAW_CMD" ] || [ "$RAW_CMD" == "status" ]; then
        CATEGORY="system"
        set -- "status"
    else
        json_error "Unknown command or category: $RAW_CMD" "1" "Try 'rxnm --help'"
        exit 1
    fi
else
    # Valid category found, shift it off args
    shift
fi

# Load dependencies
case "$CATEGORY" in
    wifi) 
        source "${LIB_DIR}/rxnm-wifi.sh" 
        source "${LIB_DIR}/rxnm-interfaces.sh" 
        ;;
    interface|bridge) source "${LIB_DIR}/rxnm-interfaces.sh" ;;
    vpn|tun|tap) 
        source "${LIB_DIR}/rxnm-interfaces.sh" 
        source "${LIB_DIR}/rxnm-vpn.sh" 
        ;;
    bond|vlan|vrf|macvlan|ipvlan|veth) 
        source "${LIB_DIR}/rxnm-interfaces.sh" 
        source "${LIB_DIR}/rxnm-virt.sh" 
        ;;
    bluetooth) source "${LIB_DIR}/rxnm-bluetooth.sh" ;;
    profile) source "${LIB_DIR}/rxnm-profiles.sh" ;;
    system|config) 
        source "${LIB_DIR}/rxnm-diagnostics.sh" 
        source "${LIB_DIR}/rxnm-wifi.sh" 
        ;;
esac

# Check for category help
if [ "$SHOW_HELP" == "true" ]; then
    print_category_help "$CATEGORY"
    exit 0
fi

# Dispatch to Category Handlers
case "$CATEGORY" in
    wifi)
        ACTION=$(expand_alias "${1:-status}" "scan" "connect" "disconnect" "ap" "wps" "networks" "country" "list" "forget")
        shift
        
        # Context-aware interface default
        ARG_IFACE=""
        ARGS=("$@")
        # Parse args to see if --interface is provided
        for ((i=0; i<${#ARGS[@]}; i++)); do
            if [[ "${ARGS[$i]}" == "--interface" ]]; then
                ARG_IFACE="${ARGS[$((i+1))]}"
            fi
        done
        # If not provided, try auto-select
        if [ -z "$ARG_IFACE" ]; then
             ARG_IFACE=$(auto_select_interface "wifi")
        fi

        case "$ACTION" in
            scan)
                action_scan "$ARG_IFACE"
                ;;
            connect)
                # Parse: rxnm wifi connect <ssid> [password]
                SSID="${1:-}"; [ -n "$SSID" ] && shift
                PASS="${1:-}"; [ -n "$PASS" ] && [[ "$PASS" != --* ]] && shift
                # Handle flags
                HIDDEN="false"
                while [[ $# -gt 0 ]]; do
                    case "$1" in
                        --ssid) SSID="$2"; shift 2 ;;
                        --password) PASS="$2"; shift 2 ;;
                        --password-stdin) PASS=$(cat); shift ;;
                        --hidden) HIDDEN="true"; shift ;;
                        --interface) ARG_IFACE="$2"; shift 2 ;;
                        *) shift ;;
                    esac
                done
                action_connect "$SSID" "$PASS" "$ARG_IFACE" "$HIDDEN"
                ;;
            disconnect)
                 while [[ $# -gt 0 ]]; do
                    case "$1" in --interface) ARG_IFACE="$2"; shift 2 ;; *) shift ;; esac
                done
                action_disconnect "$ARG_IFACE"
                ;;
            ap)
                SUBCMD="${1:-}"; shift
                case "$SUBCMD" in
                    start)
                        SSID="${1:-}"; [ -n "$SSID" ] && shift
                        PASS="${1:-}"; [ -n "$PASS" ] && [[ "$PASS" != --* ]] && shift
                        MODE="ap"; SHARE="false"; IP=""
                         while [[ $# -gt 0 ]]; do
                            case "$1" in
                                --ssid) SSID="$2"; shift 2 ;;
                                --password) PASS="$2"; shift 2 ;;
                                --mode) MODE="$2"; shift 2 ;;
                                --share) SHARE="true"; shift ;;
                                --ip) IP="$2"; shift 2 ;;
                                --interface) ARG_IFACE="$2"; shift 2 ;;
                                *) shift ;;
                            esac
                        done
                        action_host "$SSID" "$PASS" "$MODE" "$SHARE" "$IP" "$ARG_IFACE" ""
                        ;;
                    stop)
                        while [[ $# -gt 0 ]]; do
                            case "$1" in --interface) ARG_IFACE="$2"; shift 2 ;; *) shift ;; esac
                        done
                        action_client "$ARG_IFACE"
                        ;;
                esac
                ;;
            wps)
                action_wps "$ARG_IFACE"
                ;;
            networks|list) # Merge networks and list
                SUBCMD="${1:-}"; [ "$SUBCMD" == "list" ] && shift || true
                if [ "$SUBCMD" == "forget" ]; then shift; fi # handle 'wifi networks forget'
                if [ "$ACTION" == "forget" ] || [ "$SUBCMD" == "forget" ]; then
                    SSID="${1:-}"; [ -n "$SSID" ] && shift
                    confirm_action "Forget network '$SSID'?" "$FORCE_ACTION"
                    action_forget "$SSID"
                else
                    action_list_known_networks
                fi
                ;;
            forget)
                 SSID="${1:-}"; [ -n "$SSID" ] && shift
                 confirm_action "Forget network '$SSID'?" "$FORCE_ACTION"
                 action_forget "$SSID"
                 ;;
            country)
                CODE="${1:-}"
                action_set_country "$CODE"
                ;;
        esac
        ;;

    interface)
        # Logic: rxnm interface [target] [action] OR rxnm interface [action] --interface [target]
        ARG_1="${1:-}"
        ARG_2="${2:-}"
        
        TARGET=""
        ACTION=""
        
        # Heuristic: Is ARG_1 a command?
        POTENTIAL_ACTION=$(expand_alias "$ARG_1" "show" "set" "enable" "disable" "list")
        
        if [ "$POTENTIAL_ACTION" == "$ARG_1" ]; then
            # Format: rxnm interface action [options]
            ACTION="$ARG_1"
            shift
        else
            # Format: rxnm interface target action
            TARGET="$ARG_1"
            shift
            ACTION=$(expand_alias "${1:-show}" "show" "set" "enable" "disable")
            shift
        fi
        
        # Parse trailing flags
        while [[ $# -gt 0 ]]; do
             case "$1" in --interface) TARGET="$2"; shift 2 ;; *) ARGS+=("$1"); shift ;; esac
        done
        set -- "${ARGS[@]}"

        case "$ACTION" in
            show)
                action_status "$TARGET"
                ;;
            enable)
                [ -z "$TARGET" ] && { json_error "Interface name required"; exit 1; }
                action_set_link "$TARGET" "on" "on" # Naive enable
                ;;
            disable)
                [ -z "$TARGET" ] && { json_error "Interface name required"; exit 1; }
                action_set_link "$TARGET" "off" "off"
                ;;
            set)
                SUBCMD="${1:-}"; shift
                METRIC=""
                case "$SUBCMD" in
                    dhcp)
                         while [[ $# -gt 0 ]]; do
                            case "$1" in
                                --metric) METRIC="$2"; shift 2 ;;
                                *) shift ;;
                            esac
                        done
                         action_set_dhcp "$TARGET" "" "" "" "" "yes" "yes" "$METRIC"
                         ;;
                    static)
                         IP="${1:-}"; [ -n "$IP" ] && [[ "$IP" != --* ]] && shift
                         GW=""; DNS=""
                         while [[ $# -gt 0 ]]; do
                            case "$1" in
                                --ip) IP="$2"; shift 2 ;;
                                --gateway) GW="$2"; shift 2 ;;
                                --dns) DNS="$2"; shift 2 ;;
                                --metric) METRIC="$2"; shift 2 ;;
                                *) shift ;;
                            esac
                        done
                         action_set_static "$TARGET" "$IP" "$GW" "$DNS" "" "" "" "yes" "yes" "$METRIC"
                         ;;
                esac
                ;;
            list)
                action_status "" # Show all
                ;;
        esac
        ;;
        
    system)
        ACTION=$(expand_alias "${1:-status}" "status" "check" "proxy" "reload")
        shift
        case "$ACTION" in
            status)
                action_status "${1:-}"
                ;;
            check)
                SUBCMD="${1:-}"; shift
                if [ "$SUBCMD" == "internet" ]; then action_check_internet; fi
                if [ "$SUBCMD" == "portal" ]; then action_check_portal "${1:-}"; fi
                ;;
            proxy)
                 SUBCMD="${1:-}"; shift
                 if [ "$SUBCMD" == "set" ]; then
                    HTTP=""; HTTPS=""; NO=""
                    IFACE=""
                    while [[ $# -gt 0 ]]; do
                        case "$1" in
                            --http) HTTP="$2"; shift 2 ;;
                            --https) HTTPS="$2"; shift 2 ;;
                            --noproxy) NO="$2"; shift 2 ;;
                            --interface) IFACE="$2"; shift 2 ;;
                            *) shift ;;
                        esac
                    done
                    action_set_proxy "$IFACE" "$HTTP" "$HTTPS" "$NO"
                 fi
                 ;;
            reload)
                 action_reload
                 ;;
        esac
        ;;
        
    bluetooth)
        ACTION="${1:-}"; shift
        case "$ACTION" in
            pan)
                SUBCMD="${1:-}"; shift
                MODE="client"; SHARE="false"; IP=""
                # Mapping enable/disable/status
                case "$SUBCMD" in
                    enable)
                        while [[ $# -gt 0 ]]; do
                            case "$1" in
                                --mode) MODE="$2"; shift 2 ;;
                                --share) SHARE="true"; shift ;;
                                --ip) IP="$2"; shift 2 ;;
                                *) shift ;;
                            esac
                        done
                        action_pan_net "enable" "" "" "$IP" "$MODE" "$SHARE"
                        ;;
                    disable)
                        action_pan_net "disable" "" "" "" "" ""
                        ;;
                esac
                ;;
            scan)
                action_bt_scan
                ;;
            pair)
                MAC="${1:-}"; shift
                [ -z "$MAC" ] && { json_error "MAC address required"; exit 1; }
                action_bt_pair "$MAC"
                ;;
            unpair)
                MAC="${1:-}"; shift
                [ -z "$MAC" ] && { json_error "MAC address required"; exit 1; }
                action_bt_unpair "$MAC"
                ;;
        esac
        ;;

    bridge|bond|vrf|vlan|macvlan|ipvlan|veth)
         # Syntax: rxnm bridge create br0 / rxnm bridge delete br0
         ACTION="${1:-}"; shift
         NAME="${1:-}"; [ -n "$NAME" ] && [[ "$NAME" != --* ]] && shift
         
         if [ "$ACTION" == "delete" ]; then
             [ -z "$NAME" ] && { json_error "Name required"; exit 1; }
             action_delete_netdev "$NAME"
             exit 0
         fi
         
         case "$CATEGORY" in
            bridge)
                if [ "$ACTION" == "create" ]; then action_create_bridge "$NAME"; fi
                if [ "$ACTION" == "add-member" ]; then
                     IFACE="${1:-}"; shift
                     while [[ $# -gt 0 ]]; do case "$1" in --bridge) NAME="$2"; shift 2;; *) shift ;; esac; done
                     action_set_member "$IFACE" "$NAME"
                fi
                ;;
            bond)
                if [ "$ACTION" == "create" ]; then action_create_bond "$NAME" "active-backup"; fi
                if [ "$ACTION" == "add-slave" ]; then
                     IFACE="${1:-}"; shift
                     while [[ $# -gt 0 ]]; do case "$1" in --bond) NAME="$2"; shift 2;; *) shift ;; esac; done
                     action_set_bond_slave "$IFACE" "$NAME"
                fi
                ;;
            vrf)
                if [ "$ACTION" == "create" ]; then
                     TABLE=""
                     while [[ $# -gt 0 ]]; do
                        case "$1" in --table) TABLE="$2"; shift 2 ;; *) shift ;; esac
                     done
                     action_create_vrf "$NAME" "$TABLE"
                fi
                ;;
            vlan)
                if [ "$ACTION" == "create" ]; then
                     PARENT=""; ID=""
                     while [[ $# -gt 0 ]]; do
                        case "$1" in 
                            --parent) PARENT="$2"; shift 2 ;;
                            --id) ID="$2"; shift 2 ;;
                            *) shift ;;
                        esac
                     done
                     [ -z "$PARENT" ] && { json_error "Parent required (--parent)"; exit 1; }
                     [ -z "$ID" ] && { json_error "ID required (--id)"; exit 1; }
                     action_create_vlan "$PARENT" "$NAME" "$ID"
                fi
                ;;
            # ... (macvlan/ipvlan/veth similar pattern, condensed for brevity) ...
         esac
         ;;

    vpn|tun|tap)
        # Handle simple tun/tap create
        if [[ "$CATEGORY" == "tun" || "$CATEGORY" == "tap" ]] || [[ "$1" == "tun" || "$1" == "tap" ]]; then
             KIND="$CATEGORY"
             [ "$KIND" == "vpn" ] && KIND="$1" && shift
             ACTION="${1:-create}"; shift
             NAME="${1:-}"; shift
             USER=""; GROUP=""
             if [ "$ACTION" == "delete" ]; then
                 action_delete_vpn "$NAME"
                 exit 0
             fi
             while [[ $# -gt 0 ]]; do
                case "$1" in --user) USER="$2"; shift 2;; --group) GROUP="$2"; shift 2;; *) shift;; esac
             done
             [ "$KIND" == "tun" ] && action_create_tun "$NAME" "$USER" "$GROUP"
             [ "$KIND" == "tap" ] && action_create_tap "$NAME" "$USER" "$GROUP"
             exit 0
        fi

        # Handle WireGuard
        if [ "$1" == "wireguard" ]; then shift; fi
        ACTION="${1:-}"; shift
        NAME="${1:-}"; [ -n "$NAME" ] && [[ "$NAME" != --* ]] && shift
        
        case "$ACTION" in
            connect)
                PRIV=""; PEER=""; ENDP=""; IPS=""
                while [[ $# -gt 0 ]]; do
                    case "$1" in
                        --private-key) PRIV="$2"; shift 2 ;;
                        --peer-key) PEER="$2"; shift 2 ;;
                        --endpoint) ENDP="$2"; shift 2 ;;
                        --allowed-ips) IPS="$2"; shift 2 ;;
                        --address) IP="$2"; shift 2 ;;
                        *) shift ;;
                    esac
                done
                action_connect_wireguard "$NAME" "$PRIV" "$PEER" "$ENDP" "$IPS" "$IP" ""
                ;;
            disconnect|delete)
                action_disconnect_wireguard "$NAME"
                ;;
        esac
        ;;

    profile)
        ACTION="${1:-}"; shift
        NAME="${1:-}"; [ -n "$NAME" ] && [[ "$NAME" != --* ]] && shift
        IFACE=""
        FILE=""
        while [[ $# -gt 0 ]]; do
             case "$1" in 
                 --interface) IFACE="$2"; shift 2 ;; 
                 --file) FILE="$2"; shift 2 ;;
                 *) shift ;; 
             esac
        done
        
        # If action is import, Name might be implicit or mapped differently
        if [ "$ACTION" == "import" ] && [ -z "$FILE" ] && [ -f "$NAME" ]; then
            FILE="$NAME"
        fi
        
        action_profile "$ACTION" "$NAME" "$IFACE" "$FILE"
        ;;
        
    *)
        json_error "Command category '$CATEGORY' not implemented yet." "1"
        exit 1
        ;;
esac
