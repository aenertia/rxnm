#!/bin/bash
# SPDX-License-Identifier: GPL-2.0-or-later
# Copyright (C) 2026-present Joel WirƒÅmu Pauling <aenertia@aenertia.net>
#
# ROCKNIX Network Manager (Modular)
# Phase 2: Hierarchical CLI Implementation

# Debug trigger
if [ -n "${RXNM_DEBUG:-}" ]; then
    set -x
fi

# Ensure no ANSI color codes in output from tools like iwctl
export TERM=dumb

# Safety options
set -euo pipefail
IFS=$'\n\t'
shopt -s nullglob

# --- BOOTSTRAP ---
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do
  DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
LIB_DIR="${SCRIPT_DIR}/../lib"

if [ ! -f "${LIB_DIR}/rxnm-constants.sh" ]; then
    LIB_DIR="/usr/lib/rocknix-network-manager/lib"
fi

if [ ! -f "${LIB_DIR}/rxnm-constants.sh" ]; then
    echo "ERROR: Could not locate library directory." >&2
    exit 1
fi

# Source Core
source "${LIB_DIR}/rxnm-constants.sh"
source "${LIB_DIR}/rxnm-utils.sh"
source "${LIB_DIR}/rxnm-system.sh"
source "${LIB_DIR}/rxnm-config-builder.sh"

# --- GLOBAL VARIABLES & DEFAULTS ---
export RXNM_FORMAT="human"
FORCE_ACTION="false"
CATEGORY=""
ACTION=""

# --- ARGUMENT PARSING HELPER ---
# Simple prefix matcher for short aliases (e.g., 'wi' -> 'wifi')
expand_alias() {
    local input="$1"
    local options=("${@:2}")
    local match=""
    
    for opt in "${options[@]}"; do
        if [[ "$opt" == "$input" ]]; then
            echo "$opt"
            return 0
        fi
        if [[ "$opt" == "$input"* ]]; then
            if [ -n "$match" ]; then return 1; fi # Ambiguous
            match="$opt"
        fi
    done
    
    [ -n "$match" ] && echo "$match" || echo "$input"
}

# --- GLOBAL OPTIONS PARSING ---
# Parse flags that appear before subcommands or anywhere
ARGS=()
while [[ $# -gt 0 ]]; do
    case "$1" in
        --json) RXNM_FORMAT="json"; shift ;;
        --format) RXNM_FORMAT="$2"; shift 2 ;;
        --yes|-y|--force) FORCE_ACTION="true"; shift ;;
        --debug) export RXNM_DEBUG=1; set -x; shift ;;
        --help|-h) ACTION="help"; break ;;
        *) ARGS+=("$1"); shift ;;
    esac
done
set -- "${ARGS[@]}"

# --- HIERARCHY DISPATCHER ---

# Categories
CATS=("wifi" "interface" "bluetooth" "bridge" "bond" "vrf" "vlan" "macvlan" "ipvlan" "veth" "vpn" "tun" "tap" "profile" "system" "config")

# Determine Category
RAW_CMD="${1:-status}"
CATEGORY=$(expand_alias "$RAW_CMD" "${CATS[@]}")

# Validate Category or Handle Default
if [[ ! " ${CATS[*]} " =~ " ${CATEGORY} " ]]; then
    # If explicitly status or empty, default to system status
    if [ -z "$RAW_CMD" ] || [ "$RAW_CMD" == "status" ]; then
        CATEGORY="system"
        set -- "status"
    else
        echo "Unknown command or category: $RAW_CMD" >&2
        echo "Available categories: ${CATS[*]}" >&2
        exit 1
    fi
else
    # Valid category found, shift it off args
    shift
fi

# Load dependencies based on category
case "$CATEGORY" in
    wifi) 
        source "${LIB_DIR}/rxnm-wifi.sh" 
        source "${LIB_DIR}/rxnm-interfaces.sh" # Needed for auto-DHCP on connect
        ;;
    interface|bridge) source "${LIB_DIR}/rxnm-interfaces.sh" ;;
    vpn|tun|tap) 
        source "${LIB_DIR}/rxnm-interfaces.sh" # Needs network config builder base
        source "${LIB_DIR}/rxnm-vpn.sh" 
        ;;
    bond|vlan|vrf|macvlan|ipvlan|veth) 
        source "${LIB_DIR}/rxnm-interfaces.sh" # Needs network config builder and base reconfigure tools
        source "${LIB_DIR}/rxnm-virt.sh" 
        ;;
    bluetooth) source "${LIB_DIR}/rxnm-bluetooth.sh" ;;
    profile) source "${LIB_DIR}/rxnm-profiles.sh" ;;
    system|config) 
        source "${LIB_DIR}/rxnm-diagnostics.sh" 
        source "${LIB_DIR}/rxnm-wifi.sh" # Status needs wifi maps
        ;;
esac

# Dispatch to Category Handlers
case "$CATEGORY" in
    wifi)
        ACTION=$(expand_alias "${1:-status}" "scan" "connect" "disconnect" "ap" "wps" "networks" "country")
        shift
        
        # Context-aware interface default
        ARG_IFACE=""
        ARGS=("$@")
        # Parse args to see if --interface is provided
        for ((i=0; i<${#ARGS[@]}; i++)); do
            if [[ "${ARGS[$i]}" == "--interface" ]]; then
                ARG_IFACE="${ARGS[$((i+1))]}"
            fi
        done
        # If not provided, try auto-select
        if [ -z "$ARG_IFACE" ]; then
             ARG_IFACE=$(auto_select_interface "wifi")
        fi

        case "$ACTION" in
            scan)
                action_scan "$ARG_IFACE"
                ;;
            connect)
                # Parse: rxnm wifi connect <ssid> [password]
                SSID="${1:-}"; [ -n "$SSID" ] && shift
                PASS="${1:-}"; [ -n "$PASS" ] && [[ "$PASS" != --* ]] && shift
                # Handle flags
                HIDDEN="false"
                while [[ $# -gt 0 ]]; do
                    case "$1" in
                        --ssid) SSID="$2"; shift 2 ;;
                        --password) PASS="$2"; shift 2 ;;
                        --password-stdin) PASS=$(cat); shift ;;
                        --hidden) HIDDEN="true"; shift ;;
                        --interface) ARG_IFACE="$2"; shift 2 ;;
                        *) shift ;;
                    esac
                done
                action_connect "$SSID" "$PASS" "$ARG_IFACE" "$HIDDEN"
                ;;
            disconnect)
                 while [[ $# -gt 0 ]]; do
                    case "$1" in --interface) ARG_IFACE="$2"; shift 2 ;; *) shift ;; esac
                done
                action_disconnect "$ARG_IFACE"
                ;;
            ap)
                SUBCMD="${1:-}"; shift
                case "$SUBCMD" in
                    start)
                        SSID="${1:-}"; [ -n "$SSID" ] && shift
                        PASS="${1:-}"; [ -n "$PASS" ] && [[ "$PASS" != --* ]] && shift
                        MODE="ap"; SHARE="false"; IP=""
                         while [[ $# -gt 0 ]]; do
                            case "$1" in
                                --ssid) SSID="$2"; shift 2 ;;
                                --password) PASS="$2"; shift 2 ;;
                                --mode) MODE="$2"; shift 2 ;;
                                --share) SHARE="true"; shift ;;
                                --ip) IP="$2"; shift 2 ;;
                                --interface) ARG_IFACE="$2"; shift 2 ;;
                                *) shift ;;
                            esac
                        done
                        action_host "$SSID" "$PASS" "$MODE" "$SHARE" "$IP" "$ARG_IFACE" ""
                        ;;
                    stop)
                        while [[ $# -gt 0 ]]; do
                            case "$1" in --interface) ARG_IFACE="$2"; shift 2 ;; *) shift ;; esac
                        done
                        action_client "$ARG_IFACE"
                        ;;
                esac
                ;;
            wps)
                action_wps "$ARG_IFACE"
                ;;
            networks)
                SUBCMD="${1:-}"; shift
                if [ "$SUBCMD" == "forget" ]; then
                    SSID="${1:-}"; [ -n "$SSID" ] && shift
                    confirm_action "Forget network '$SSID'?" "$FORCE_ACTION"
                    action_forget "$SSID"
                fi
                ;;
            country)
                CODE="${1:-}"
                action_set_country "$CODE"
                ;;
        esac
        ;;

    interface)
        ACTION=$(expand_alias "${1:-show}" "show" "set" "enable" "disable")
        shift
        # Format: rxnm interface <name> <action> or rxnm interface <action> --interface <name>
        ARG_IFACE=""
        if [[ "$1" != "show" && "$1" != "set" && "$1" != "enable" && "$1" != "disable" && "$1" != -* ]]; then
             ARG_IFACE="$1"; shift
        fi
        
        case "$ACTION" in
            show)
                action_status "$ARG_IFACE"
                ;;
            set)
                SUBCMD="${1:-}"; shift
                METRIC=""
                case "$SUBCMD" in
                    dhcp)
                         # Parse args for metric overrides
                         while [[ $# -gt 0 ]]; do
                            case "$1" in
                                --metric) METRIC="$2"; shift 2 ;;
                                --interface) ARG_IFACE="$2"; shift 2 ;;
                                *) shift ;;
                            esac
                        done
                         action_set_dhcp "$ARG_IFACE" "" "" "" "" "yes" "yes" "$METRIC"
                         ;;
                    static)
                         IP="${1:-}"; [ -n "$IP" ] && [[ "$IP" != --* ]] && shift
                         # Parse rest
                         GW=""; DNS=""
                         while [[ $# -gt 0 ]]; do
                            case "$1" in
                                --ip) IP="$2"; shift 2 ;;
                                --gateway) GW="$2"; shift 2 ;;
                                --dns) DNS="$2"; shift 2 ;;
                                --metric) METRIC="$2"; shift 2 ;;
                                --interface) ARG_IFACE="$2"; shift 2 ;;
                                *) shift ;;
                            esac
                        done
                         action_set_static "$ARG_IFACE" "$IP" "$GW" "$DNS" "" "" "" "yes" "yes" "$METRIC"
                         ;;
                esac
                ;;
        esac
        ;;
        
    system)
        ACTION=$(expand_alias "${1:-status}" "status" "check" "proxy" "reload")
        shift
        case "$ACTION" in
            status)
                action_status "${1:-}"
                ;;
            check)
                SUBCMD="${1:-}"; shift
                if [ "$SUBCMD" == "internet" ]; then action_check_internet; fi
                if [ "$SUBCMD" == "portal" ]; then action_check_portal "${1:-}"; fi
                ;;
            proxy)
                 SUBCMD="${1:-}"; shift
                 if [ "$SUBCMD" == "set" ]; then
                    HTTP=""; HTTPS=""; NO=""
                    IFACE=""
                    while [[ $# -gt 0 ]]; do
                        case "$1" in
                            --http) HTTP="$2"; shift 2 ;;
                            --https) HTTPS="$2"; shift 2 ;;
                            --noproxy) NO="$2"; shift 2 ;;
                            --interface) IFACE="$2"; shift 2 ;;
                            *) shift ;;
                        esac
                    done
                    action_set_proxy "$IFACE" "$HTTP" "$HTTPS" "$NO"
                 fi
                 ;;
            reload)
                 action_reload
                 ;;
        esac
        ;;
        
    bluetooth)
        ACTION="${1:-}"; shift
        case "$ACTION" in
            pan)
                SUBCMD="${1:-}"; shift
                MODE="client"; SHARE="false"; IP=""
                # Mapping enable/disable/status
                case "$SUBCMD" in
                    enable)
                        while [[ $# -gt 0 ]]; do
                            case "$1" in
                                --mode) MODE="$2"; shift 2 ;;
                                --share) SHARE="true"; shift ;;
                                --ip) IP="$2"; shift 2 ;;
                                *) shift ;;
                            esac
                        done
                        action_pan_net "enable" "" "" "$IP" "$MODE" "$SHARE"
                        ;;
                    disable)
                        action_pan_net "disable" "" "" "" "" ""
                        ;;
                esac
                ;;
        esac
        ;;

    bridge|bond|vrf|vlan|macvlan|ipvlan|veth)
         # Simplified dispatch for virtual devices
         ACTION="${1:-}"; shift
         NAME="${1:-}"; [ -n "$NAME" ] && [[ "$NAME" != --* ]] && shift
         
         case "$CATEGORY" in
            bridge)
                if [ "$ACTION" == "create" ]; then action_create_bridge "$NAME"; fi
                if [ "$ACTION" == "add-member" ]; then
                     IFACE="${1:-}"; shift
                     action_set_member "$IFACE" "$NAME"
                fi
                ;;
            bond)
                if [ "$ACTION" == "create" ]; then action_create_bond "$NAME" "active-backup"; fi
                if [ "$ACTION" == "add-slave" ]; then
                     IFACE="${1:-}"; shift
                     action_set_bond_slave "$IFACE" "$NAME"
                fi
                ;;
            vrf)
                if [ "$ACTION" == "create" ]; then
                     TABLE=""
                     while [[ $# -gt 0 ]]; do
                        case "$1" in --table) TABLE="$2"; shift 2 ;; *) shift ;; esac
                     done
                     action_create_vrf "$NAME" "$TABLE"
                fi
                if [ "$ACTION" == "add-member" ]; then
                     IFACE="${1:-}"; shift
                     action_set_vrf_member "$IFACE" "$NAME"
                fi
                ;;
            macvlan)
                if [ "$ACTION" == "create" ]; then
                     PARENT=""; MODE="bridge"
                     while [[ $# -gt 0 ]]; do
                        case "$1" in 
                            --parent) PARENT="$2"; shift 2 ;;
                            --mode) MODE="$2"; shift 2 ;;
                            *) shift ;;
                        esac
                     done
                     [ -z "$PARENT" ] && { echo "Error: --parent required"; exit 1; }
                     action_create_macvlan "$NAME" "$PARENT" "$MODE"
                     # json_success handled in action
                fi
                ;;
            ipvlan)
                if [ "$ACTION" == "create" ]; then
                     PARENT=""; MODE="L2"
                     while [[ $# -gt 0 ]]; do
                        case "$1" in 
                            --parent) PARENT="$2"; shift 2 ;;
                            --mode) MODE="$2"; shift 2 ;;
                            *) shift ;;
                        esac
                     done
                     [ -z "$PARENT" ] && { echo "Error: --parent required"; exit 1; }
                     action_create_ipvlan "$NAME" "$PARENT" "$MODE"
                fi
                ;;
            veth)
                if [ "$ACTION" == "create" ]; then
                     PEER=""
                     while [[ $# -gt 0 ]]; do
                        case "$1" in --peer) PEER="$2"; shift 2 ;; *) shift ;; esac
                     done
                     [ -z "$PEER" ] && { echo "Error: --peer required"; exit 1; }
                     action_create_veth "$NAME" "$PEER"
                fi
                ;;
            vlan)
                if [ "$ACTION" == "create" ]; then
                     PARENT=""; ID=""
                     while [[ $# -gt 0 ]]; do
                        case "$1" in 
                            --parent) PARENT="$2"; shift 2 ;;
                            --id) ID="$2"; shift 2 ;;
                            *) shift ;;
                        esac
                     done
                     [ -z "$PARENT" ] && { echo "Error: --parent required"; exit 1; }
                     [ -z "$ID" ] && { echo "Error: --id required"; exit 1; }
                     action_create_vlan "$PARENT" "$NAME" "$ID"
                fi
                ;;
         esac
         ;;

    vpn|tun|tap)
        if [ "$ACTION" == "wireguard" ]; then
             SUBCMD="${1:-}"; shift
             NAME="${1:-}"; shift
             if [ "$SUBCMD" == "connect" ]; then
                PRIV=""; PEER=""; ENDP=""; IPS=""
                while [[ $# -gt 0 ]]; do
                    case "$1" in
                        --private-key) PRIV="$2"; shift 2 ;;
                        --peer-key) PEER="$2"; shift 2 ;;
                        --endpoint) ENDP="$2"; shift 2 ;;
                        --allowed-ips) IPS="$2"; shift 2 ;;
                        --address) IP="$2"; shift 2 ;;
                        *) shift ;;
                    esac
                done
                action_connect_wireguard "$NAME" "$PRIV" "$PEER" "$ENDP" "$IPS" "$IP" ""
             fi
        elif [ "$ACTION" == "tun" ] || [ "$CATEGORY" == "tun" ]; then
             if [ "$ACTION" == "create" ] || [ "$1" == "create" ]; then
                 # Handle rxnm vpn tun create vs rxnm tun create
                 [[ "$ACTION" == "create" ]] && shift || { shift; shift; }
                 NAME="${1:-}"; shift
                 USER=""; GROUP=""
                 while [[ $# -gt 0 ]]; do
                    case "$1" in
                        --user) USER="$2"; shift 2 ;;
                        --group) GROUP="$2"; shift 2 ;;
                        *) shift ;;
                    esac
                 done
                 [ -z "$NAME" ] && { echo "Error: Name required"; exit 1; }
                 action_create_tun "$NAME" "$USER" "$GROUP"
             fi
        elif [ "$ACTION" == "tap" ] || [ "$CATEGORY" == "tap" ]; then
             if [ "$ACTION" == "create" ] || [ "$1" == "create" ]; then
                 [[ "$ACTION" == "create" ]] && shift || { shift; shift; }
                 NAME="${1:-}"; shift
                 USER=""; GROUP=""
                 while [[ $# -gt 0 ]]; do
                    case "$1" in
                        --user) USER="$2"; shift 2 ;;
                        --group) GROUP="$2"; shift 2 ;;
                        *) shift ;;
                    esac
                 done
                 [ -z "$NAME" ] && { echo "Error: Name required"; exit 1; }
                 action_create_tap "$NAME" "$USER" "$GROUP"
             fi
        fi
        ;;

    profile)
        ACTION="${1:-}"; shift
        NAME="${1:-}"; [ -n "$NAME" ] && [[ "$NAME" != --* ]] && shift
        IFACE=""
        while [[ $# -gt 0 ]]; do
             case "$1" in --interface) IFACE="$2"; shift 2 ;; *) shift ;; esac
        done
        action_profile "$ACTION" "$NAME" "$IFACE"
        ;;
        
    *)
        echo "Command category '$CATEGORY' not implemented yet."
        exit 1
        ;;
esac
