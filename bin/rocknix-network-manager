#!/bin/bash
# SPDX-License-Identifier: GPL-2.0-or-later
# Copyright (C) 2026-present Joel WirƒÅmu Pauling <aenertia@aenertia.net>
#
# ROCKNIX Network Manager (Modular)

# CRITICAL: Verify we are running under Bash, not BusyBox Ash
if [ -z "$BASH_VERSION" ]; then
    echo "Error: This script requires bash (busybox ash not supported)" >&2
    exit 1
fi

# Debug trigger
if [ -n "${RXNM_DEBUG:-}" ]; then
    set -x
fi

# Ensure no ANSI color codes in output from tools like iwctl
export TERM=dumb

# Safety options
set -euo pipefail
IFS=$'\n\t'
shopt -s nullglob

# --- BOOTSTRAP ---
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do
  DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
LIB_DIR="${SCRIPT_DIR}/../lib"

# Export LIB_DIR so sourced scripts can access it
export LIB_DIR
export RXNM_LIB_DIR="${LIB_DIR}"

if [ ! -f "${LIB_DIR}/rxnm-constants.sh" ]; then
    # Fallback to system install path if relative path fails
    LIB_DIR="/usr/lib/rocknix-network-manager/lib"
    export LIB_DIR
    export RXNM_LIB_DIR="${LIB_DIR}"
fi

if [ ! -f "${LIB_DIR}/rxnm-constants.sh" ]; then
    echo "ERROR: Could not locate library directory." >&2
    exit 1
fi

# Source Core
source "${LIB_DIR}/rxnm-constants.sh"
source "${LIB_DIR}/rxnm-utils.sh"
source "${LIB_DIR}/rxnm-system.sh"
source "${LIB_DIR}/rxnm-config-builder.sh"
source "${LIB_DIR}/rxnm-plugins.sh"

# --- GLOBAL VARIABLES & DEFAULTS ---
export RXNM_FORMAT="human"
FORCE_ACTION="false"
CATEGORY=""
ACTION=""

# --- ARGUMENT PARSING HELPER ---
expand_alias() {
    local input="$1"
    local options=("${@:2}")
    local match=""
    
    for opt in "${options[@]}"; do
        if [[ "$opt" == "$input" ]]; then
            echo "$opt"
            return 0
        fi
        if [[ "$opt" == "$input"* ]]; then
            if [ -n "$match" ]; then return 1; fi # Ambiguous
            match="$opt"
        fi
    done
    
    [ -n "$match" ] && echo "$match" || echo "$input"
}

print_main_help() {
    local plugins
    plugins=$(list_plugins)
    
    cat <<EOF
Usage: rxnm <category> [target] <action> [options]

Categories:
  wifi          Manage Wireless connections
  interface     Configure interfaces (IP, DHCP, State)
  system        Status, diagnostics, global settings
  profile       Manage configuration profiles
  bluetooth     Bluetooth Tethering (PAN/NAP)
  vpn           WireGuard and Tunnels
  bridge        Manage Network Bridges
  bond          Manage Interface Bonding
  vlan          Manage VLANs
  vrf           Manage Virtual Routing Functions
EOF

    if [ -n "$plugins" ]; then
        echo ""
        echo "Plugins / Helpers:"
        echo "$plugins" | awk '{print "  " $0}'
    fi

    cat <<EOF

Global Options:
  --format <fmt>  Output format: human (default), json, table
  --yes, -y       Skip confirmation prompts
  --help, -h      Show help
  --version       Show version

Examples:
  rxnm wifi connect "MyNetwork"
  rxnm interface wlan0 set dhcp
  rxnm system status --format table
  rxnm bridge create br0

Use 'rxnm <category> --help' for specific commands.
EOF
}

print_category_help() {
    local category="$1"
    
    # Check if this category is handled by a plugin
    local plugin_path
    plugin_path=$(find_plugin "$category")
    if [ -n "$plugin_path" ]; then
        echo "Help for plugin '$category':"
        # Try to invoke the plugin with --help if it supports it
        exec_plugin "$plugin_path" "--help" || echo "  No help available for this plugin."
        return
    fi

    case "$category" in
        wifi)
            cat <<EOF
Usage: rxnm wifi <action> [options]

Actions:
  scan [iface]          Scan for networks
  connect <ssid>        Connect to a network
  disconnect [iface]    Disconnect from current AP
  list                  List known networks
  forget <ssid>         Forget a known network
  ap start <ssid>       Start Access Point (Hotspot)
  country <code>        Set WiFi Country Code
  
  p2p scan              Scan for WiFi Direct peers
  p2p connect <name>    Connect to P2P peer
  p2p disconnect        Disconnect P2P
  p2p status            Show P2P status (Peers/GO Mode)
  
  dpp enroll <uri>      Start DPP enrollment (QR code string)
  dpp stop              Stop DPP session
  
  roaming monitor       Start opportunistic roaming monitor

Options:
  --password <pass>     WiFi Password
  --password-stdin      Read password from stdin (Secure)
  --hidden              Connect to hidden SSID
  --interface <iface>   Target interface (Auto-detected if omitted)
  --ip <cidr>           Custom IP for AP mode
  --share               Enable NAT/Masquerading for AP
  --ipv6-pd <yes|no>    Enable/Disable IPv6 Prefix Delegation (Default: yes)
EOF
            ;;
        interface)
            cat <<EOF
Usage: rxnm interface [name] <action> [options]

Actions:
  show                  Show interface details
  set dhcp              Enable DHCP
  set static <ip>       Set Static IP (CIDR format)
  enable / disable      Set link state
  list                  List all interfaces

Options:
  --gateway <ip>        Set Gateway
  --dns <ip>            Set DNS servers (comma separated)
  --metric <int>        Route metric priority
  --mtu <int>           Set MTU (68-65535)
  --mac <addr>          Set MAC Address (XX:XX:XX:XX:XX:XX)
  --ipv6-privacy <opt>  Set IPv6 Privacy (yes|no|prefer-public|kernel)
  --dhcp-id <opt>       Set DHCP Client ID (mac|duid)
  --ipv6-pd <yes|no>    Enable/Disable IPv6 Prefix Delegation (Default: yes)
EOF
            ;;
        profile)
            cat <<EOF
Usage: rxnm profile <action> [name] [options]

RXNM uses a RAM-first architecture. Changes are ephemeral unless saved to a profile.
The 'default' profile is automatically loaded to RAM at boot.

Actions:
  list                  List saved persistent profiles
  save [name]           Save active state to profile (defaults to 'default')
  load [name]           Load profile into RAM (defaults to 'default')
  delete <name>         Delete a persistent profile
  export <name>         Export profile to tarball
  import <file>         Import profile from tarball

Options:
  --interface <iface>   Scope profile to a specific interface
EOF
            ;;
        bridge|bond|vlan|vrf|macvlan|ipvlan|veth)
            cat <<EOF
Usage: rxnm $category <action> <name> [options]

Actions:
  create <name>         Create new virtual device
  delete <name>         Delete device
  add-member <iface>    Add interface to $category (Bridge/VRF only)
  add-slave <iface>     Add interface to $category (Bond only)
  list                  List devices (via rxnm interface list)

Options:
  --parent <iface>      Parent interface (VLAN/MacVLAN/IPVLAN)
  --id <vlan-id>        VLAN ID (1-4094)
  --mode <mode>         Mode for Bond (active-backup, etc) or MacVLAN
  --table <id>          Routing table ID for VRF
  --peer <name>         Peer interface name (veth only)
EOF
            ;;
        vpn)
            cat <<EOF
Usage: rxnm vpn wireguard <action> <name> [options]

Actions:
  connect <name>        Create/Connect WireGuard interface
  disconnect <name>     Remove WireGuard interface
  delete <name>         Alias for disconnect

Options:
  --private-key <key>   WireGuard Private Key
  --peer-key <key>      Peer Public Key
  --endpoint <addr:port> Remote Endpoint
  --allowed-ips <cidr>  Allowed IPs (e.g. 0.0.0.0/0)
  --address <cidr>      Interface Address
EOF
            ;;
        tun|tap)
             cat <<EOF
Usage: rxnm $category create <name> [options]
       rxnm $category delete <name>

Options:
  --user <user>         Owner of the interface
  --group <group>       Group owner
EOF
            ;;
        bluetooth)
            cat <<EOF
Usage: rxnm bluetooth <action> [options]

Actions:
  scan                  Scan for devices
  pair <mac>            Pair with device
  unpair <mac>          Unpair device
  pan enable            Enable PAN Tethering
  pan disable           Disable PAN Tethering

Options (for pan enable):
  --mode <client|host>  Client (connect to phone) or Host (share net)
  --share               Enable NAT (Host mode only)
EOF
            ;;
        system)
            cat <<EOF
Usage: rxnm system <action> [options]

Actions:
  status                Show network status
  check internet        Check internet connectivity
  check portal          Check for captive portal
  reload                Reload network configuration
  proxy set             Configure global/interface proxy
EOF
            ;;
        *)
            echo "No specific help for '$category'."
            ;;
    esac
}

# --- GLOBAL OPTIONS PARSING ---
# Parse flags that appear before subcommands or anywhere
ARGS=()
SHOW_HELP="false"

while [[ $# -gt 0 ]]; do
    case "$1" in
        --json) RXNM_FORMAT="json"; shift ;;
        --format) RXNM_FORMAT="$2"; shift 2 ;;
        --yes|-y|--force) FORCE_ACTION="true"; shift ;;
        --debug) export RXNM_DEBUG=1; set -x; shift ;;
        --help|-h) SHOW_HELP="true"; shift ;;
        *) ARGS+=("$1"); shift ;;
    esac
done
set -- "${ARGS[@]}"

# If help requested at root
if [ "$SHOW_HELP" == "true" ] && [ $# -eq 0 ]; then
    print_main_help
    exit 0
fi

# --- HIERARCHY DISPATCHER ---

# Built-in Categories
CATS=("wifi" "interface" "bluetooth" "bridge" "bond" "vrf" "vlan" "macvlan" "ipvlan" "veth" "vpn" "tun" "tap" "profile" "system" "config")

# Determine Category
RAW_CMD="${1:-status}"
CATEGORY=$(expand_alias "$RAW_CMD" "${CATS[@]}")

# 1. Plugin Dispatch (Highest Priority)
# Check if a plugin exists for this category (Extension or Override)
PLUGIN_EXEC=$(find_plugin "$CATEGORY" || true)

if [ -n "$PLUGIN_EXEC" ]; then
    # If a plugin is found, we hand over control immediately.
    shift
    
    # Check for help on the plugin itself if requested
    if [ "$SHOW_HELP" == "true" ]; then
        exec_plugin "$PLUGIN_EXEC" "--help"
        exit 0
    fi
    
    exec_plugin "$PLUGIN_EXEC" "$@"
fi

# 2. Built-in Dispatch
IS_VALID_CAT=false
for valid_cat in "${CATS[@]}"; do
    if [[ "$valid_cat" == "$CATEGORY" ]]; then
        IS_VALID_CAT=true
        break
    fi
done

if [ "$IS_VALID_CAT" = false ]; then
    if [ -z "$RAW_CMD" ] || [ "$RAW_CMD" == "status" ]; then
        # Default to system status if no args or just 'status'
        CATEGORY="system"
        set -- "status"
    else
        json_error "Unknown command or category: $RAW_CMD" "1" "Try 'rxnm --help'"
        exit 1
    fi
else
    shift
fi

# Load dependencies
case "$CATEGORY" in
    wifi) 
        source "${LIB_DIR}/rxnm-wifi.sh" 
        source "${LIB_DIR}/rxnm-interfaces.sh" 
        # NEW: Load Roaming Engine
        source "${LIB_DIR}/rxnm-roaming.sh"
        ;;
    interface|bridge) source "${LIB_DIR}/rxnm-interfaces.sh" ;;
    vpn|tun|tap) 
        source "${LIB_DIR}/rxnm-interfaces.sh" 
        source "${LIB_DIR}/rxnm-vpn.sh" 
        ;;
    bond|vlan|vrf|macvlan|ipvlan|veth) 
        source "${LIB_DIR}/rxnm-interfaces.sh" 
        source "${LIB_DIR}/rxnm-virt.sh" 
        ;;
    bluetooth) source "${LIB_DIR}/rxnm-bluetooth.sh" ;;
    profile) source "${LIB_DIR}/rxnm-profiles.sh" ;;
    system|config) 
        source "${LIB_DIR}/rxnm-diagnostics.sh" 
        source "${LIB_DIR}/rxnm-wifi.sh" 
        ;;
esac

# Check for category help
if [ "$SHOW_HELP" == "true" ]; then
    print_category_help "$CATEGORY"
    exit 0
fi

# Dispatch to Category Handlers
case "$CATEGORY" in
    wifi)
        ACTION=$(expand_alias "${1:-status}" "scan" "connect" "disconnect" "ap" "wps" "networks" "country" "list" "forget" "p2p" "dpp" "roaming")
        shift
        
        ARG_IFACE=""
        ARGS=("$@")
        for ((i=0; i<${#ARGS[@]}; i++)); do
            if [[ "${ARGS[$i]}" == "--interface" ]]; then
                ARG_IFACE="${ARGS[$((i+1))]}"
            fi
        done
        # Roaming monitor might run without a specific iface initially, but we auto-detect
        if [ -z "$ARG_IFACE" ] && [ "$ACTION" != "roaming" ]; then
             ARG_IFACE=$(get_wifi_iface || echo "")
        fi

        case "$ACTION" in
            scan)
                action_scan "$ARG_IFACE"
                ;;
            connect)
                SSID="${1:-}"; [ -n "$SSID" ] && shift
                PASS="${1:-}"; [ -n "$PASS" ] && [[ "$PASS" != --* ]] && shift
                HIDDEN="false"
                while [[ $# -gt 0 ]]; do
                    case "$1" in
                        --ssid) SSID="$2"; shift 2 ;;
                        --password) PASS="$2"; shift 2 ;;
                        --password-stdin) PASS=$(cat); shift ;;
                        --hidden) HIDDEN="true"; shift ;;
                        --interface) ARG_IFACE="$2"; shift 2 ;;
                        *) shift ;;
                    esac
                done
                action_connect "$SSID" "$PASS" "$ARG_IFACE" "$HIDDEN"
                ;;
            disconnect)
                 while [[ $# -gt 0 ]]; do
                    case "$1" in --interface) ARG_IFACE="$2"; shift 2 ;; *) shift ;; esac
                done
                action_disconnect "$ARG_IFACE"
                ;;
            ap)
                SUBCMD="${1:-}"; shift
                if [ "$SUBCMD" == "start" ]; then
                    SSID="${1:-}"; [ -n "$SSID" ] && shift
                    PASS="${1:-}"; [ -n "$PASS" ] && [[ "$PASS" != --* ]] && shift
                    MODE="ap"; SHARE="false"; IP=""; IPV6_PD="yes"
                     while [[ $# -gt 0 ]]; do
                        case "$1" in
                            --ssid) SSID="$2"; shift 2 ;;
                            --password) PASS="$2"; shift 2 ;;
                            --mode) MODE="$2"; shift 2 ;;
                            --share) SHARE="true"; shift ;;
                            --ip) IP="$2"; shift 2 ;;
                            --interface) ARG_IFACE="$2"; shift 2 ;;
                            --ipv6-pd) IPV6_PD="$2"; shift 2 ;;
                            *) shift ;;
                        esac
                    done
                    action_host "$SSID" "$PASS" "$MODE" "$SHARE" "$IP" "$ARG_IFACE" "" "$IPV6_PD"
                elif [ "$SUBCMD" == "stop" ]; then
                    while [[ $# -gt 0 ]]; do
                        case "$1" in --interface) ARG_IFACE="$2"; shift 2 ;; *) shift ;; esac
                    done
                    action_client "$ARG_IFACE"
                fi
                ;;
            wps)
                action_wps "$ARG_IFACE"
                ;;
            networks|list)
                action_list_known_networks
                ;;
            forget)
                 SSID="${1:-}"; [ -n "$SSID" ] && shift
                 confirm_action "Forget network '$SSID'?" "$FORCE_ACTION"
                 action_forget "$SSID"
                 ;;
            country)
                action_set_country "${1:-}"
                ;;
            p2p)
                SUBCMD="${1:-}"; shift
                case "$SUBCMD" in
                    scan) action_p2p_scan ;;
                    connect) action_p2p_connect "${1:-}" ;;
                    disconnect) action_p2p_disconnect ;;
                    status) action_p2p_status ;;
                esac
                ;;
            dpp)
                SUBCMD="${1:-}"; shift
                if [ "$SUBCMD" == "enroll" ]; then action_dpp_enroll "$ARG_IFACE" "${1:-}"; fi
                if [ "$SUBCMD" == "stop" ]; then action_dpp_stop "$ARG_IFACE"; fi
                ;;
            roaming)
                SUBCMD="${1:-}"; shift
                if [ "$SUBCMD" == "monitor" ]; then
                    action_wifi_roaming_monitor
                else
                    echo "Usage: rxnm wifi roaming monitor"
                fi
                ;;
        esac
        ;;

    interface)
        ARG_1="${1:-}"
        TARGET=""
        ACTION=""
        
        # Valid actions for this category
        VALID_ACTS=("show" "set" "enable" "disable" "list")
        
        # Attempt expansion of first arg as a keyword
        EXPANDED=$(expand_alias "$ARG_1" "${VALID_ACTS[@]}")
        
        # Validate if the expanded result is actually one of our keywords
        IS_KEYWORD=false
        for v in "${VALID_ACTS[@]}"; do
            if [[ "$v" == "$EXPANDED" ]]; then IS_KEYWORD=true; break; fi
        done
        
        if [ "$IS_KEYWORD" == "true" ]; then
            # Command-first syntax: rxnm interface set eth0 ...
            ACTION="$EXPANDED"
            shift
            # If next arg is not a flag, it's the target
            if [[ "${1:-}" != --* ]] && [ -n "${1:-}" ]; then
                TARGET="$1"
                shift
            fi
        else
            # Object-first syntax: rxnm interface eth0 set ...
            TARGET="$ARG_1"
            shift
            ACTION=$(expand_alias "${1:-show}" "${VALID_ACTS[@]}")
            shift
        fi
        
        # Flag args override
        ARGS=("$@")
        while [[ $# -gt 0 ]]; do
             case "$1" in 
                --interface) TARGET="$2"; shift 2 ;; 
                *) shift ;; 
             esac
        done
        # Reset args for subcommand parsing
        set -- "${ARGS[@]}"

        case "$ACTION" in
            show) action_status "$TARGET" ;;
            enable)
                [ -z "$TARGET" ] && { json_error "Interface name required"; exit 1; }
                action_set_link "$TARGET" "on" "on"
                ;;
            disable)
                [ -z "$TARGET" ] && { json_error "Interface name required"; exit 1; }
                action_set_link "$TARGET" "off" "off"
                ;;
            set)
                SUBCMD="${1:-}"; shift
                METRIC=""
                MTU=""
                MAC=""
                IPV6_PRIV=""
                DHCP_ID=""
                IPV6_PD=""
                case "$SUBCMD" in
                    dhcp)
                         while [[ $# -gt 0 ]]; do
                            case "$1" in 
                                --metric) METRIC="$2"; shift 2 ;; 
                                --mtu) MTU="$2"; shift 2 ;;
                                --mac) MAC="$2"; shift 2 ;;
                                --ipv6-privacy) IPV6_PRIV="$2"; shift 2 ;;
                                --dhcp-id) DHCP_ID="$2"; shift 2 ;;
                                --ipv6-pd) IPV6_PD="$2"; shift 2 ;;
                                *) shift ;; 
                            esac
                        done
                         action_set_dhcp "$TARGET" "" "" "" "" "yes" "yes" "$METRIC" "$MTU" "$MAC" "$IPV6_PRIV" "$DHCP_ID" "$IPV6_PD"
                         ;;
                    static)
                         IP="${1:-}"; [ -n "$IP" ] && [[ "$IP" != --* ]] && shift
                         GW=""; DNS=""
                         while [[ $# -gt 0 ]]; do
                            case "$1" in
                                --ip) IP="$2"; shift 2 ;;
                                --gateway) GW="$2"; shift 2 ;;
                                --dns) DNS="$2"; shift 2 ;;
                                --metric) METRIC="$2"; shift 2 ;;
                                --mtu) MTU="$2"; shift 2 ;;
                                --mac) MAC="$2"; shift 2 ;;
                                --ipv6-privacy) IPV6_PRIV="$2"; shift 2 ;;
                                --dhcp-id) DHCP_ID="$2"; shift 2 ;;
                                *) shift ;;
                            esac
                        done
                         action_set_static "$TARGET" "$IP" "$GW" "$DNS" "" "" "" "yes" "yes" "$METRIC" "$MTU" "$MAC" "$IPV6_PRIV" "$DHCP_ID"
                         ;;
                esac
                ;;
            list) action_status "" ;;
        esac
        ;;
        
    system)
        ACTION=$(expand_alias "${1:-status}" "status" "check" "proxy" "reload" "setup" "start" "stop")
        shift
        case "$ACTION" in
            status) action_status "${1:-}" ;;
            check)
                SUBCMD="${1:-}"; shift
                if [ "$SUBCMD" == "internet" ]; then action_check_internet; fi
                if [ "$SUBCMD" == "portal" ]; then action_check_portal "${1:-}"; fi
                ;;
            proxy)
                 SUBCMD="${1:-}"; shift
                 if [ "$SUBCMD" == "set" ]; then
                    HTTP=""; HTTPS=""; NO=""; IFACE=""
                    while [[ $# -gt 0 ]]; do
                        case "$1" in
                            --http) HTTP="$2"; shift 2 ;;
                            --https) HTTPS="$2"; shift 2 ;;
                            --noproxy) NO="$2"; shift 2 ;;
                            --interface) IFACE="$2"; shift 2 ;;
                            *) shift ;;
                        esac
                    done
                    action_set_proxy "$IFACE" "$HTTP" "$HTTPS" "$NO"
                 fi
                 ;;
            reload) action_reload ;;
            setup|start) action_setup ;;
            stop) action_stop ;;
        esac
        ;;
        
    bluetooth)
        ACTION="${1:-}"; shift
        case "$ACTION" in
            pan)
                SUBCMD="${1:-}"; shift
                MODE="client"; SHARE="false"; IP=""
                case "$SUBCMD" in
                    enable)
                        while [[ $# -gt 0 ]]; do
                            case "$1" in
                                --mode) MODE="$2"; shift 2 ;;
                                --share) SHARE="true"; shift ;;
                                --ip) IP="$2"; shift 2 ;;
                                *) shift ;;
                            esac
                        done
                        action_pan_net "enable" "" "" "$IP" "$MODE" "$SHARE"
                        ;;
                    disable) action_pan_net "disable" "" "" "" "" "" ;;
                esac
                ;;
            scan) action_bt_scan ;;
            pair)
                MAC="${1:-}"; shift
                [ -z "$MAC" ] && { json_error "MAC address required"; exit 1; }
                action_bt_pair "$MAC"
                ;;
            unpair)
                MAC="${1:-}"; shift
                [ -z "$MAC" ] && { json_error "MAC address required"; exit 1; }
                action_bt_unpair "$MAC"
                ;;
        esac
        ;;

    bridge|bond|vrf|vlan|macvlan|ipvlan|veth)
         ACTION="${1:-}"; shift
         NAME="${1:-}"; [ -n "$NAME" ] && [[ "$NAME" != --* ]] && shift
         
         if [ "$ACTION" == "delete" ]; then
             [ -z "$NAME" ] && { json_error "Name required"; exit 1; }
             action_delete_netdev "$NAME"
             exit 0
         fi
         
         case "$CATEGORY" in
            bridge)
                if [ "$ACTION" == "create" ]; then action_create_bridge "$NAME"; fi
                if [ "$ACTION" == "add-member" ]; then
                     IFACE="${1:-}"; 
                     if [ -z "$IFACE" ] || [[ "$IFACE" == --* ]]; then IFACE="$NAME"; fi
                     BRIDGE=""
                     while [[ $# -gt 0 ]]; do case "$1" in --bridge) BRIDGE="$2"; shift 2;; *) shift ;; esac; done
                     action_set_member "$IFACE" "$BRIDGE"
                fi
                ;;
            bond)
                if [ "$ACTION" == "create" ]; then action_create_bond "$NAME" "active-backup"; fi
                if [ "$ACTION" == "add-slave" ]; then
                     IFACE="${1:-}";
                     if [ -z "$IFACE" ] || [[ "$IFACE" == --* ]]; then IFACE="$NAME"; fi
                     BOND=""
                     while [[ $# -gt 0 ]]; do case "$1" in --bond) BOND="$2"; shift 2;; *) shift ;; esac; done
                     action_set_bond_slave "$IFACE" "$BOND"
                fi
                ;;
            vrf)
                if [ "$ACTION" == "create" ]; then
                     TABLE=""
                     while [[ $# -gt 0 ]]; do case "$1" in --table) TABLE="$2"; shift 2 ;; *) shift ;; esac; done
                     action_create_vrf "$NAME" "$TABLE"
                fi
                if [ "$ACTION" == "add-member" ]; then
                     IFACE="${1:-}";
                     if [ -z "$IFACE" ] || [[ "$IFACE" == --* ]]; then IFACE="$NAME"; fi
                     VRF=""
                     while [[ $# -gt 0 ]]; do case "$1" in --vrf) VRF="$2"; shift 2;; *) shift ;; esac; done
                     action_set_vrf_member "$IFACE" "$VRF"
                fi
                ;;
            vlan)
                if [ "$ACTION" == "create" ]; then
                     PARENT=""; ID=""
                     while [[ $# -gt 0 ]]; do
                        case "$1" in 
                            --parent) PARENT="$2"; shift 2 ;;
                            --id) ID="$2"; shift 2 ;;
                            *) shift ;;
                        esac
                     done
                     [ -z "$PARENT" ] && { json_error "Parent required (--parent)"; exit 1; }
                     [ -z "$ID" ] && { json_error "ID required (--id)"; exit 1; }
                     action_create_vlan "$PARENT" "$NAME" "$ID"
                fi
                ;;
            macvlan)
                if [ "$ACTION" == "create" ]; then
                     PARENT=""; MODE="bridge"
                     while [[ $# -gt 0 ]]; do
                        case "$1" in
                            --parent) PARENT="$2"; shift 2 ;;
                            --mode) MODE="$2"; shift 2 ;;
                            *) shift ;;
                        esac
                     done
                     action_create_macvlan "$NAME" "$PARENT" "$MODE"
                fi
                ;;
         esac
         ;;

    vpn|tun|tap)
        if [[ "$CATEGORY" == "tun" || "$CATEGORY" == "tap" ]] || [[ "$1" == "tun" || "$1" == "tap" ]]; then
             KIND="$CATEGORY"; [ "$KIND" == "vpn" ] && KIND="$1" && shift
             ACTION="${1:-create}"; shift; NAME="${1:-}"; shift
             USER=""; GROUP=""
             if [ "$ACTION" == "delete" ]; then action_delete_vpn "$NAME"; exit 0; fi
             while [[ $# -gt 0 ]]; do
                case "$1" in --user) USER="$2"; shift 2;; --group) GROUP="$2"; shift 2;; *) shift ;; esac
             done
             [ "$KIND" == "tun" ] && action_create_tun "$NAME" "$USER" "$GROUP"
             [ "$KIND" == "tap" ] && action_create_tap "$NAME" "$USER" "$GROUP"
             exit 0
        fi

        if [ "$1" == "wireguard" ]; then shift; fi
        ACTION="${1:-}"; shift; NAME="${1:-}"; [ -n "$NAME" ] && [[ "$NAME" != --* ]] && shift
        case "$ACTION" in
            connect)
                PRIV=""; PEER=""; ENDP=""; IPS=""; IP=""
                while [[ $# -gt 0 ]]; do
                    case "$1" in
                        --private-key) PRIV="$2"; shift 2 ;;
                        --peer-key) PEER="$2"; shift 2 ;;
                        --endpoint) ENDP="$2"; shift 2 ;;
                        --allowed-ips) IPS="$2"; shift 2 ;;
                        --address) IP="$2"; shift 2 ;;
                        *) shift ;;
                    esac
                done
                action_connect_wireguard "$NAME" "$PRIV" "$PEER" "$ENDP" "$IPS" "$IP" ""
                ;;
            disconnect|delete) action_disconnect_wireguard "$NAME" ;;
        esac
        ;;

    profile)
        ACTION="${1:-}"; shift; NAME="${1:-}"; [ -n "$NAME" ] && [[ "$NAME" != --* ]] && shift
        IFACE=""; FILE=""
        while [[ $# -gt 0 ]]; do
             case "$1" in 
                 --interface) IFACE="$2"; shift 2 ;; 
                 --file) FILE="$2"; shift 2 ;;
                 *) shift ;; 
             esac
        done
        if [ "$ACTION" == "import" ] && [ -z "$FILE" ] && [ -f "$NAME" ]; then FILE="$NAME"; fi
        action_profile "$ACTION" "$NAME" "$IFACE" "$FILE"
        ;;
        
    *)
        json_error "Command category '$CATEGORY' not implemented yet." "1"; exit 1 ;;
esac
